\documentclass{article}

\usepackage{fullpage}
\usepackage{amsmath, stmaryrd, amssymb, mathtools, mathpartir}

% Sets
\newcommand{\SetOf}[1]{\left\{#1\right\}}

% Sorts
\newcommand{\IHExp}{\mathsf{IHExp}}
\newcommand{\IHTagExp}{\mathsf{IHTagExp}}
\newcommand{\HExp}{\mathsf{HExp}}
\newcommand{\HTyp}{\mathsf{HTyp}}
\newcommand{\HTag}{\mathsf{HTag}}
\newcommand{\HTagExp}{\mathsf{HTagExp}}
\newcommand{\HTagTyp}{\mathsf{HTagTyp}}
\newcommand{\HTagVar}{\mathsf{HTagVar}}
\newcommand{\EvalCtx}{\mathsf{EvalCtx}}

% Types
\newcommand{\rectype}[2]{\mu #1.#2}
\newcommand{\sumtype}[1]{+\mathopen{}\left\{#1\right\}}

% Tags
\newcommand{\C}{\mathcal{C}}
\newcommand{\Tag}{\mathbf{C}}
\newcommand{\TagHole}[1][u]{{?^{#1}}}
\newcommand{\Nothing}{\varnothing}

% Expressions
\newcommand{\eroll}[1]{\mathtt{roll}\mathopen{}\left(#1\right)\mathclose{}}
\newcommand{\droll}[2]{\mathtt{roll}^{#1}\mathopen{}\left(#2\right)\mathclose{}}
\newcommand{\unroll}[1]{\mathtt{unroll}\mathopen{}\left(#1\right)\mathclose{}}
\newcommand{\einj}[2]{\mathtt{inj}_{#1}\mathopen{}\left(#2\right)\mathclose{}}
\newcommand{\dinj}[3]{\mathtt{inj}_{#2}^{#1}\mathopen{}\left(#3\right)\mathclose{}}
\newcommand{\case}[2]{\mathtt{case} \left(#1\right) \left\{#2\right\}}
\newcommand{\hole}[1][]{\llparenthesis#1\rrparenthesis}

% Judgments
\newcommand{\valid}[2]{#1 \vdash #2~\mathsf{valid}}
\newcommand{\assign}[4]{#1; #2 \vdash #3 : #4}
\newcommand{\syn}[3]{#1 \vdash #2 \Rightarrow #3}
\newcommand{\ana}[3]{#1 \vdash #2 \Leftarrow #3}
\newcommand{\synelab}[5]{#1 \vdash #2 \Rightarrow #3 \leadsto #4 \dashv #5}
\newcommand{\anaelab}[6]{#1 \vdash #2 \Leftarrow #3 \leadsto #4 : #5 \dashv #6}
\newcommand{\anaE}[3]{#1 \vdash_E #2 \Leftarrow #3}
\newcommand{\synelabE}[5]{#1 \vdash_E #2 \Rightarrow #3 \leadsto #4 \dashv #5}
\newcommand{\anaelabE}[6]{#1 \vdash_E #2 \Leftarrow #3 \leadsto #4 : #5 \dashv #6}
\newcommand{\assignD}[4]{#1; #2 \vdash_D #3 : #4}
\newcommand{\consistent}[2]{#1 \sim #2}
\newcommand{\matchedRec}[2]{#1 \blacktriangleright_\mu #2}
\newcommand{\join}[2]{\mathsf{join}\left(#1,#2\right)}
\newcommand{\ground}[1]{#1~\mathsf{ground}}
\newcommand{\matchedGround}[2]{#1 \blacktriangleright_{\mathsf{ground}} #2}
\newcommand{\val}[1]{#1~\mathsf{val}}
\newcommand{\boxedval}[1]{#1~\mathsf{boxedval}}
\newcommand{\indet}[1]{#1~\mathsf{indet}}
\newcommand{\final}[1]{#1~\mathsf{final}}
\newcommand{\eval}[3]{#1 = #2\mathopen{}\left\{#3\right\}\mathclose{}}

% Evaluation Contexts
\newcommand{\E}{\mathcal{E}}

% Operations
\newcommand{\subst}[3]{[#1 / #2]#3}
\newcommand{\defeq}{\stackrel{\text{def}}{=}}
\newcommand{\cast}[3]{#1\langle#2\,{\Rightarrow}\,#3\rangle}

% Helpers
\DeclareMathOperator{\id}{\text{id}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Algebraic Data Types for Hazel}
\author{Eric Griffis \\ egriffis@umich.edu}
\date{}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Syntax}

\[
  \arraycolsep=0pt  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \IHExp & d & {}\Coloneqq{} &
      \ldots
      \mid \droll{\rectype{\alpha}{\tau}}{d}
      \mid \unroll{d}
      \mid \dinj{\tau}{C}{D}
      \mid \case{d}{C_i(X_i){=}d_i}_{C_i \in \C}
    \\
    \HExp & e & {}\Coloneqq{} &
      \ldots
      \mid \eroll{e}
      \mid \unroll{e}
      \mid \einj{C}{E}
      \mid \case{e}{C_i(X_i){=}e_i}_{C_i \in \C}
    \\
    \HTyp & \tau & {}\Coloneqq{} &
      \ldots
      \mid (\rectype{\alpha}{\tau})
      \mid \alpha
      \mid \sumtype{C_i(T_i)}_{C_i \in \C}
    \\
    \HTag & C & {}\Coloneqq{} &
      \Tag
      \mid \TagHole
    \\
    \IHTagExp & D & {}\Coloneqq{} & d \mid \Nothing \\
    \HTagExp & E & {}\Coloneqq{} & e \mid \Nothing \\
    \HTagTyp & T & {}\Coloneqq{} & \tau \mid \Nothing \\
    \HTagVar & X & {}\Coloneqq{} & x \mid \Nothing \\
  \end{array}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Static Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\consistent{\tau}{\tau'}}$
\quad $\tau$ and $\tau'$ are consistent
%
\begin{mathpar}
  \inferrule[TCRec]{
    \consistent{\tau_1}{ \subst{\alpha_1}{\alpha_2}{\tau_2} }
  }{
    \consistent{
      \rectype{\alpha_1}{\tau_1}
    }{
      \rectype{\alpha_2}{\tau_2}
     }
  }

  \inferrule[TCVar]{
    % 
  }{
    \consistent{\alpha}{\alpha}
  }

  \inferrule[TCSum]{
    \consistent{\tau_i}{\tau_i'}
  }{
    \consistent{
      \sumtype{C_i(\tau_i)}_{C_i \in \C}
    }{
      \sumtype{C_i(\tau_i')}_{C_i \in \C}
    }
  }
\end{mathpar}

For \textsc{TCRec}, we choose to substitute $\alpha_1$ for $\alpha_2$ arbitrarily.
Due to this asymmetry, recursive types are only consistent up to alpha renaming.

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\matchedRec{\tau}{\rectype{\alpha}{\tau'}}}$
\quad $\tau$ has matched recursive type $\rectype{\alpha}{\tau'}$
%
\begin{mathpar}
  \inferrule[MRRec]{
  }{
    \matchedRec{
      \rectype{\alpha}{\tau}
    }{
      \rectype{\alpha}{\tau}
    }
  }

  \inferrule[MRHole]{
  }{
    \matchedRec{
      \hole
    }{
      \rectype{\alpha}{\hole}
    }
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\join{\tau_1}{\tau_2} = \tau}$
\quad $\tau_1$ and $\tau_2$ join consistently, forming type $\tau$
%
\begin{mathpar}
  \join{
    \sumtype{C_i(\tau_i)}_{C_i \in \C}
  }{
    \sumtype{C_i(\tau_i')}_{C_i \in \C}
  }
  = \sumtype{C_i(\join{\tau_i}{\tau_i'})}_{C_i \in \C}

  \join{
    \rectype{\alpha_1}{\tau_1}
  }{
    \rectype{\alpha_2}{\tau_2}
  }
  = \rectype{\alpha_1}{\join{\tau_1}{ \subst{\alpha_1}{\alpha_2}{\tau_2} }}
\end{mathpar}

% \vspace*{\baselineskip}

\subsection{Bidirectional Typing}

We call $\subst{\rectype{\alpha}{\tau}}{\alpha}{\tau}$ the \emph{unrolling} of
recursive type $\rectype{\alpha}{\tau}$.

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e => tau

\noindent
$\boxed{\syn{\Gamma}{e}{\tau}}$
\quad $e$ synthesizes type $\tau$
%
\begin{mathpar}
  \inferrule[SUnroll]{
    \syn{\Gamma}{e}{\tau'} \\
    \matchedRec{ \tau' }{ \rectype{\alpha}{\tau} }
  }{
    \syn{\Gamma}{
      \unroll{e}
    }{ \subst{ \rectype{\alpha}{\tau} }{\alpha}{\tau} }
  }

  \inferrule[SInj]{
    \valid{\Gamma}{E}
  }{
    \syn{\Gamma}{\hole[\einj{C}{E}]^u}{\hole}
  }  
\end{mathpar}

\textsc{SInj} = Injection in Synthetic Position or Analyzed Against Non-Sum

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- E valid

\noindent
$\boxed{\valid{\Gamma}{E}}$
\quad $E$ is a valid expression
%
\begin{mathpar}
  \inferrule[]{
    \ana{\Gamma}{e}{\hole}
  }{
    \valid{\Gamma}{e}
  }

  \inferrule[]{
    % 
  }{
    \valid{\Gamma}{\Nothing}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e <= tau

\noindent
$\boxed{\ana{\Gamma}{e}{\tau}}$
\quad $e$ analyzes against type $\tau$
%
\begin{mathpar}
  \inferrule[ARoll]{
    \matchedRec{\tau}{\rectype{\alpha}{\tau'}} \\
    \ana{\Gamma}{e}{\subst{ \rectype{\alpha}{\tau'} }{\alpha}{\tau'}}
  }{
    \ana{\Gamma}{\eroll{e}}{\tau}
  }

  \inferrule[AInjHole]{
    \valid{\Gamma}{E}
  }{
    \ana{\Gamma}{ \einj{C}{E} }{\hole}
  }

  \inferrule[AInj]{
    C_j \in \C \\
    \anaE{\Gamma}{E}{T_j}
  }{
    \ana{\Gamma}{
      \einj{C_j}{E}
    }{\sumtype{C_i(T_i)}_{C_i \in \C}}
  }

  \inferrule[AInjUnexpectedBody]{
    C_j \in \C \\
    T_j = \Nothing
  }{
    \ana{\Gamma}{
      \hole[\einj{C_j}{e}]^u
    }{\sumtype{C_i(T_i)}_{C_i \in \C}}
  }

  \inferrule[AInjExpectedBody]{
    C_j \in \C \\
    T_j = \tau
  }{
    \ana{\Gamma}{
      \hole[\einj{C_j}{\Nothing}]^u
    }{\sumtype{C_i(T_i)}_{C_i \in \C}}
  }

  \inferrule[AInjBadTag]{
    C \notin \C \\
    \valid{\Gamma}{E}
  }{
    \ana{\Gamma}{
      \hole[\einj{C}{E}]^u
    }{\sumtype{C_i(T_i)}_{C_i \in \C}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- E <= T

\noindent
$\boxed{\anaE{\Gamma}{E}{T}}$
\quad $E$ analyzes against optional type $T$
%
\begin{mathpar}
  \inferrule[]{
    \ana{\Gamma}{e}{\tau}
  }{
    \anaE{\Gamma}{e}{\tau}
  }

  \inferrule[]{
    % 
  }{
    \anaE{\Gamma}{\Nothing}{\Nothing}
  }
\end{mathpar}

% \vspace*{\baselineskip}

\subsection{Typed Elaboration}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e => tau ~> d -| Delta

\noindent
$\boxed{\synelab{\Gamma}{e}{\tau}{d}{\Delta}}$
\quad $e$ synthesizes type $\tau$ and elaborates to $d$
%
\begin{mathpar}
  \inferrule[ESUnroll]{
    \synelab{\Gamma}{e}{\tau'}{d}{\Delta} \\
    \matchedRec{\tau'}{\rectype{\alpha}{\tau}}
  }{
    \synelab{\Gamma}{
      \unroll{e}
    }{ \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau} }{
      \unroll{d}
    }{\Delta}
  }

  \inferrule[ESInj]{
    \anaelabE{\Gamma}{E}{\hole}{D}{T}{\Delta}
  }{
    \synelab{\Gamma}{
      \hole[\einj{C}{E}]^u
    }{\hole}{
      \hole[{\dinj{\hole}{C}{\cast{D}{T}{\hole}}}]_{\id(\Gamma)}^u
    }{\Delta, u :: \hole{}[\Gamma]}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e <= tau_1 ~> d : tau_2 -| Delta

% TODO: define D<T => T>
% TODO: add u as hole macro param

\noindent
$\boxed{\anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}}$
\quad $e$ analyzes against type $\tau_1$ and elaborates to $d$ of consistent type $\tau_2$
%
\begin{mathpar}
  \inferrule[EARoll]{
    \anaelab{\Gamma}{
      e
    }{\subst{ \rectype{\alpha}{\tau} }{\alpha}{\tau}}{
      d
    }{\tau'}{\Delta}
  }{
    \anaelab{\Gamma}{
      \eroll{e}
    }{\rectype{\alpha}{\tau}}{
      \droll{\rectype{\alpha}{\tau}}{
        \cast{d}{\tau'}{ \subst{ \rectype{\alpha}{\tau} }{\alpha}{\tau} }
      }
    }{\rectype{\alpha}{\tau}}{
      \Delta
    }
  }

  \inferrule[EAInj]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    C_j \in \C \\
    \anaelab{\Gamma}{E}{T_j}{D}{T_j'}{\Delta}
  }{
    \anaelab{\Gamma}{
      \einj{C_j}{E}
    }{\tau}{
      \dinj{\tau}{C_j}{\cast{D}{T_j'}{T_j}}
    }{\tau}{\Delta}
  }

  \inferrule[EAInjHole]{
    \anaelabE{\Gamma}{E}{\hole}{D}{T}{\Delta} \\
    \tau = \sumtype{C(T)}
  }{
    \anaelab{\Gamma}{
      \einj{C}{E}
    }{\hole}{
      \dinj{\tau}{C}{D}
    }{\tau}{\Delta}
  }

  \inferrule[EAInjUnexpectedBody]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    C_j \in \C \\
    T_j = \Nothing \\
    \anaelab{\Gamma}{e}{\hole}{d}{\tau_j}{\Delta} \\
    \tau' = \tau \uplus \sumtype{C_j(\tau_j)}
  }{
    \anaelab{\Gamma}{
      \hole[\einj{C_j}{e}]^u
    }{\tau}{
      \hole[{\dinj{\tau'}{C_j}{d}}]_{\id(\Gamma)}^u
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjExpectedBody]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    C_j \in \C \\
    T_j = \tau_j \\
    \tau' = \tau \uplus \sumtype{C_j(\Nothing)}
  }{
    \anaelab{\Gamma}{
      \hole[\einj{C_j}{\Nothing}]^u
    }{\tau}{
      \hole[{\dinj{\tau'}{C_j}{\Nothing}}]_{\id(\Gamma)}^u
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjBadTag]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    C \notin \C \\
    \anaelabE{\Gamma}{E}{\hole}{D}{T}{\Delta} \\
    \tau' = \tau \uplus \sumtype{C(T)}
  }{
    \anaelab{\Gamma}{
      \hole[\einj{C}{E}]^u
    }{\tau}{
      \hole[{\dinj{\tau'}{C}{D}}]_{\id(\Gamma)}^u
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- E <= T_1 ~> D : T_2 -| Delta

\noindent
$\boxed{\anaelabE{\Gamma}{E}{T_1}{D}{T_2}{\Delta}}$
\quad $E$ analyzes against optional type $T_1$ and elaborates to $D$ of consistent optional type $T_2$
%
\begin{mathpar}
  \inferrule{
    \anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}   
  }{
    \anaelabE{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}
  }

  \inferrule{
    % 
  }{
    \anaelabE{\Gamma}{\Nothing}{\Nothing}{\Nothing}{\Nothing}{\emptyset}
  }
\end{mathpar}

% \vspace*{\baselineskip}

\subsection{Type Assignment}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Delta; Gamma |- d : tau

\noindent
$\boxed{\assign{\Delta}{\Gamma}{d}{\tau}}$
\quad $d$ is assigned type $\tau$
%
\begin{mathpar}
  \inferrule[TRoll]{
    \assign{\Delta}{\Gamma}{d}{ \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau} }
  }{
    \assign{\Delta}{\Gamma}{ \droll{\rectype{\alpha}{\tau}}{d} }{ \rectype{\alpha}{\tau} }
  }

  \inferrule[TUnroll]{
    \assign{\Delta}{\Gamma}{d}{ \rectype{\alpha}{\tau} }
  }{
    \assign{\Delta}{\Gamma}{\unroll{d}}{ \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau} }
  }

  \inferrule[TInj]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    C_j \in \C \\
    \assign{\Delta}{\Gamma}{D}{T_j}
  }{
    \assign{\Delta}{\Gamma}{\dinj{\tau}{C_j}{D}}{\tau}
  }

  \inferrule[TCase]{
    \assign{\Delta}{\Gamma}{d}{\sumtype{C_i(T_i)}_{C_i \in \C}} \\
    \assign{\Delta}{\Gamma, X_i : T_i}{d_i}{\tau} \\
    i = 1, \ldots, N
  }{
    \assign{\Delta}{\Gamma}{
      \case{d}{C_i(X_i){=}d_i}_{C_i \in \C}
    }{\tau}
  }

  \inferrule[TCaseU]{
    \assign{\Delta}{\Gamma}{d}{\hole} \\
    \assign{\Delta}{\Gamma, X_i : \hole}{d_i}{\tau} \\
    i = 1, \ldots, N
  }{
    \assign{\Delta}a{\Gamma}{\case{d}{C_i(X_i){=}{d_i}}_{C_i \in \C}}{\tau}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- D : T

\noindent
$\boxed{\assignD{\Delta}{\Gamma}{D}{T}}$
\quad $D$ is assigned optional type $T$
%
\begin{mathpar}
  \inferrule{
    \assign{\Delta}{\Gamma}{d}{\tau}
  }{
    \assignD{\Delta}{\Gamma}{d}{\tau}
  }

  \inferrule{
    % 
  }{
    \assign{\Delta}{\Gamma}{\Nothing}{\Nothing}
  }
\end{mathpar}

\vspace*{\baselineskip}

% \noindent
% $\expand(\rectype{\alpha}{\tau}) \defeq \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau}$

% \vspace*{\baselineskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dynamic Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\ground{\tau}}$
\quad $\tau$ is a ground type

\begin{mathpar}
  \inferrule[GSum]{
    \SetOf{T_i = \hole \vee T_i = \Nothing}_i
  }{
    \ground{\sumtype{C_i(T_i)}_{C_i \in \C}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\matchedGround{\tau}{\tau'}}$
\quad $\tau$ has matched ground type $\tau'$

\begin{mathpar}
  \inferrule[MGSum]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    \tau' = \sumtype{C_i(T_i')}_{C_i \in \C} \\
    \tau \neq \tau' \\
    \SetOf{
      T_i =   \tau_i \implies T_i' = \hole \wedge
      T_i = \Nothing \implies T_i' = \Nothing
    }_i
  }{
    \matchedGround{\tau}{\tau'}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\val{d}}$
\quad $d$ is a value

\begin{mathpar}
  \inferrule[VRoll]{
    \val{d}
  }{
    \val{\droll{\rectype{\alpha}{\tau}}{d}}
  }

  \inferrule[VUnroll]{
    \val{d}
  }{
    \val{\unroll{d}}
  }

  \inferrule[VInj]{
    \val{d}
  }{
    \val{\dinj{\tau}{\Tag}{d}}
  }

  \inferrule[VInjNull]{
  }{
    \val{\dinj{\tau}{\Tag}{\Nothing}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\boxedval{d}}$
\quad $d$ is a boxed value

\begin{mathpar}
  \inferrule[BVRoll]{
    \boxedval{d}
  }{
    \boxedval{\droll{\rectype{\alpha}{\tau}}{d}}
  }

  \inferrule[BVUnroll]{
    \boxedval{d}
  }{
    \boxedval{\unroll{d}}
  }

  \inferrule[BVInj]{
    \boxedval{d}
  }{
    \boxedval{\dinj{\tau}{\Tag}{d}}
  }

  \inferrule[BVSumCast]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    \tau' = \sumtype{C_i(T_i')}_{C_i \in \C} \\
    \tau \neq \tau' \\
    \boxedval{d}
  }{
    \boxedval{\cast{d}{\tau}{\tau'}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\noindent
$\boxed{\indet{d}}$
\quad $d$ is indeterminate

\begin{mathpar}
  \inferrule[IRoll]{
    \indet{d}
  }{
    \indet{\droll{\rectype{\alpha}{\tau}}{d}}
  }

  \inferrule[IUnroll]{
    \indet{d}
  }{
    \indet{\unroll{d}}
  }

  \inferrule[IInj]{
    \indet{d}
  }{
    \indet{\dinj{\tau}{\Tag}{d}}
  }

  \inferrule[IInjTag]{
    \final{d}
  }{
    \indet{\dinj{\tau}{\TagHole}{d}}
  }

  \inferrule[IInjNull]{
  }{
    \indet{\dinj{\tau}{\TagHole}{\Nothing}}
  }

  \inferrule[ICastSum]{
    \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
    \tau' = \sumtype{C_i(T_i')}_{C_i \in \C} \\
    \tau \neq \tau' \\
    \indet{d}
  }{
    \indet{\cast{d}{\tau}{\tau'}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\[
  \arraycolsep=0pt  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \EvalCtx & \E & {}\Coloneqq{} &
      \ldots
      \mid \droll{\rectype{\alpha}{\tau}}{\E}
      \mid \dinj{\tau}{C}{\E}
    \\
  \end{array}
\]

\noindent
$\boxed{\eval{d}{\E}{d'}}$
\quad $d$ is obtained by placing $d'$ at the mark in $\E$

\begin{mathpar}
  \inferrule[FHRoll]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \droll{\rectype{\alpha}{\tau}}{d}
    }{\droll{\rectype{\alpha}{\tau}}{\E}
    }{d'}
  }

  \inferrule[FHUnroll]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \unroll{d}
    }{\unroll{\E}
    }{d'}
  }

  \inferrule[FHInj]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \dinj{\tau}{C}{d}
    }{\dinj{\tau}{C}{\E}
    }{d'}
  }
\end{mathpar}

\vspace*{\baselineskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}