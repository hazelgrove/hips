\documentclass{article}

\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{amsmath, stmaryrd, amssymb, mathtools, mathpartir}

% fix spacing between math operators and large paired delimiters
\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}

% Theorems and Proofs

\usepackage{amsthm}
\newtheorem{Theorem}{Theorem}
\newtheorem{Lemma}[Theorem]{Lemma}

\usepackage{pfsteps}
\renewcommand\byCasesEveryCase{}
\setlength{\proofrightwidth}{0.4\linewidth}

% Sets

\newcommand{\Set}[1]{\left\{#1\right\}}

% Sorts

\newcommand\Sort[1]{\mathsf{#1}}

\newcommand\IHExp{\Sort{IHExp}}
\newcommand\IHTagArg{\Sort{IHTagArg}}
\newcommand\HExp{\Sort{HExp}}
\newcommand\HExpPat{\Sort{HExpPat}}
\newcommand\HTag{\Sort{HTag}}
\newcommand\HTagArg{\Sort{HTagArg}}
\newcommand\HTagTyp{\Sort{HTagTyp}}
\newcommand\HTagVar{\Sort{HTagVar}}
\newcommand\HTyp{\Sort{HTyp}}
\newcommand\HTypPat{\Sort{HTypPat}}
\newcommand\EvalCtx{\Sort{EvalCtx}}

% Holes

\newcommand\hole[2][]{\llparenthesis#1\rrparenthesis^{#2}}
\newcommand\mhole[2][]{\llparenthesis#1\rrparenthesis^{#2 \blacktriangleright}}
\newcommand\dhole[3][]{\llparenthesis#1\rrparenthesis_{#2}^{#3}}
\newcommand\dmhole[3][]{\llparenthesis#1\rrparenthesis_{#2}^{#3 \blacktriangleright}}

% Types

\newcommand\Tarr[2]{#1 \rightarrow #2}
\newcommand\Trec[2]{\mu{#1}.{#2}}
\newcommand\Tsum[1]{+\mathopen{}\left\{#1\right\}}

% Tags

\newcommand\Tag{\mathbf{C}}
\newcommand\TagSet{\mathcal{C}}
\newcommand\TagHole[2][]{\hole[#1]{#2}}

% Optional Tag Arguments

\newcommand\Unit{\varnothing}

% Token Literals

\newcommand\literal[1]{\mathtt{#1}}

% Type Ascription

\newcommand\asc[2]{{#1}:{#2}}

% External Expressions

\newcommand\Efun[3]{\lambda{#1}{:}{#2}.{#3}}
\newcommand\Eapp[2]{{#1}\left({#2}\right)}
\newcommand\Einj[2]{\literal{inj}_{#1}\left({#2}\right)}
\newcommand\Ecase[2]{\literal{case} \left({#1}\right) \left\{{#2}\right\}}
\newcommand\Eroll[1]{\literal{roll}\left(#1\right)}
\newcommand\Eunroll[1]{\literal{unroll}\left(#1\right)}

% Internal Expressions

\newcommand\Dfun[3]{\lambda{#1}{:}{#2}.{#3}}
\newcommand\Dapp[2]{{#1}\left({#2}\right)}
\newcommand\Dinj[3]{\literal{inj}_{#1}^{#2}\left({#3}\right)}
\newcommand\Dcase[2]{\literal{case} \left({#1}\right) \left\{{#2}\right\}}
\newcommand\Droll[3]{\literal{roll}^{\Trec{#1}{#2}}\left({#3}\right)}
\newcommand\Dunroll[1]{\literal{unroll}\left(#1\right)}
\newcommand\cast[3]{{#1}\langle{#2}\Rightarrow{#3}\rangle}
\newcommand\casts[4]{{#1}\langle{#2}\Rightarrow{#3}\Rightarrow{#4}\rangle}
\newcommand\failedcast[3]{{#1}\langle{#2}\Rightarrow{\llparenthesis\rrparenthesis}\nRightarrow{#3}\rangle}

% Judgments

\newcommand\Judgment[2]{\noindent{}$\boxed{#1}$\quad{#2}}
\newcommand\judgment[1]{\mathrm{#1}}

\newcommand\syn[3]{{#1}\vdash{#2}\Rightarrow{#3}}
\newcommand\ana[3]{{#1}\vdash{#2}\Leftarrow{#3}}

\newcommand\synelab[5]{#1 \vdash #2 \Rightarrow #3 \leadsto #4 \dashv #5}
\newcommand\anaelab[6]{#1 \vdash #2 \Leftarrow #3 \leadsto #4 : #5 \dashv #6}

\newcommand\assign[4]{#1; #2 \vdash #3 : #4}
\newcommand\ground[1]{#1~\judgment{ground}}
\newcommand\join[2]{\mathsf{join}\left(#1,#2\right)}
\newcommand\val[1]{#1~\judgment{val}}
\newcommand\boxedval[1]{#1~\judgment{boxedval}}
\newcommand\indet[1]{#1~\judgment{indet}}
\newcommand\final[1]{#1~\judgment{final}}
\newcommand\trans[2]{#1 \longrightarrow #2}
\newcommand\eval[3]{#1 = #2\left\{#3\right\}}
\newcommand\step[2]{#1 \mapsto #2}

% Inference Rule Names

\newcommand\Rule[1]{\textsc{#1}}

% Helpers

\newcommand\helper[1]{\mathsf{#1}}

\newcommand\consistent[2]{{#1}\sim{#2}}
\newcommand\notconsistent[2]{{#1}\nsim{#2}}
\newcommand\valid[2]{{#1}\vdash{#2}\,\helper{valid}}
\newcommand\validtag[1]{{#1}\,\helper{valid}}
\newcommand\FV[1]{\helper{FV}\left(#1\right)}
\newcommand\id[1]{\helper{id}\left(#1\right)}
\newcommand\dom[1]{\helper{dom}{\left(#1\right)}}

% Matched Types

\newcommand\MatchedArrowTyp[3]{{#1}\blacktriangleright_\rightarrow{#2}\rightarrow{#3}}
\newcommand\MatchedRecTyp[3]{{#1}\blacktriangleright_\mu\Trec{#2}{#3}}
\newcommand{\MatchedGroundTyp}[2]{#1 \blacktriangleright_{\helper{ground}} #2}

% Substitution

\newcommand\subst[3]{\left[{#1}/{#2}\right]{#3}}

% Evaluation

\newcommand\E{\mathcal{E}}
\newcommand\Mark{\circ}

% Other Notation

% \newcommand{\defeq}{\stackrel{\text{def}}{=}}
\newcommand\eager[1]{{\color{red}[}#1{\color{red}]}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Algebraic Data Types for Hazel}
\author{Eric Griffis \\ egriffis@umich.edu}
\date{}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Syntax}

\[
  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \HTyp & \tau & \Coloneqq &
      \Unit
      \mid \Tarr{\tau}{\tau}
      \mid \alpha
      \mid \Trec{\pi}{\tau}
      \mid \Tsum{C_i(\tau_i)}_{C_i \in \TagSet}
      \mid \hole{}
      \mid \hole[\alpha]{}
      \\
    \HTypPat & \pi & \Coloneqq & \alpha \mid \hole{} \\
    \HExp & e & \Coloneqq &
      \Unit
      \mid x
      \mid \Efun{x}{\tau}{e}
      \mid \Eapp{e}{e}
      \mid \asc{e}{\tau}
      \mid \Einj{C}{e}
      % \mid \Ecase{e}{C_i(X_i){=}e_i}_{C_i \in \TagSet}
      \mid \Eroll{e}
      \mid \Eunroll{e}
      \\ & & &
      \mid \hole{u}
      \mid \hole[e]{u}
      \mid \mhole[e]{u}
      \\
    \IHExp & d & \Coloneqq &
      \Unit
      \mid x
      \mid \Dfun{x}{\tau}{d}
      \mid \Dapp{d}{d}
      \mid \Dinj{C}{\tau}{d}
      % \mid \Dcase{d}{C_i(X_i)}_{C_u \in \TagSet}
      \mid \Droll{\alpha}{\tau}{d}
      \mid \Dunroll{d}
      \\ & & &
      \mid \cast{d}{\tau}{\tau}
      \mid \failedcast{d}{\tau}{\tau}
      \mid \dhole{\sigma}{u}
      \mid \dhole[d]{\sigma}{u}
      \mid \dmhole[d]{\sigma}{u}
      \\
    \HTag & C & \Coloneqq &
      \Tag
      \mid \TagHole{u}
      \mid \TagHole[c]{u}
      \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsection{Context Extension}

We write $\Theta, \pi$ to denote the extension of type variable context $\Theta$ with optional type variable name $\pi$.
\[
  \Theta, \pi = \begin{cases}
    \Theta, \alpha & \pi = \alpha \\
    \Theta & \pi = \hole{} \\
  \end{cases}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Static Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  [tau/pi]tau

\Judgment{
  \subst{\tau}{\pi}{\tau'} = \tau''
}{
  $\tau''$ is obtained by substituting $\tau$ for $\pi$ in $\tau'$
}

\[
  \arraycolsep=0pt
  \begin{array}{l@{\quad=\quad}l@{\quad}l}
    \subst{\tau}{\hole{}}{\tau'} & \tau'
    \\
    \subst{\tau}{\alpha}{ \Unit } & \Unit \\
    \subst{\tau}{\alpha}{ (\Tarr{\tau_1}{\tau_2}) }
      & \Tarr{ \subst{\tau}{\alpha}{\tau_1} }{ \subst{\tau}{\alpha}{\tau_1} } \\
    \subst{\tau}{\alpha}{ \alpha } & \tau \\
    \subst{\tau}{\alpha}{ \alpha_1 } & \tau' & \text{ when } \alpha \neq \alpha_1 \\
    \subst{\tau}{\alpha}{ \Trec{\alpha_1}{\tau_2} }
      & \Trec{\alpha_1}{ \subst{\tau}{\alpha}{\tau_2} }
      & \text{ when } \alpha \neq \alpha_1 \text{ and } \alpha_1 \notin \FV{\tau} \\
    \subst{\tau}{\alpha}{ \Trec{\hole{}}{\tau_2} } & \Trec{\hole{}}{ \subst{\tau}{\alpha}{\tau_2} } \\
    \subst{\tau}{\alpha}{ \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} }
      & \Tsum{C_i( \subst{\tau}{\alpha}{\tau_i} )}_{C_i \in \TagSet} \\
    \subst{\tau}{\alpha}{ \hole{} } & \hole{} \\
    \subst{\alpha'}{\alpha}{ \hole[\alpha]{} } & \hole[\alpha']{u} \\
    \subst{\alpha'}{\alpha}{ \hole[\alpha']{u} } & \hole[\alpha']{u} & \text{ when } \alpha \neq \alpha' \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% join(tau1, tau2) = tau

% \Judgment{
%   \join{\tau_1}{\tau_2} = \tau
% }{
%   $\tau_1$ and $\tau_2$ join consistently, forming type $\tau$
% }

% \[
%   \arraycolsep=0pt
%   \begin{array}{l@{\quad=\quad}l@{\quad}l}
%     \join{ \tau }{ \tau } & \tau \\
%     \join{ \hole{} }{ \tau } & \tau \\
%     \join{ \tau }{ \hole{} } & \tau \\
%     \join{
%       \Tarr{\tau_1}{\tau_2}
%     }{
%       \Tarr{\tau_1'}{\tau_2'}
%     }
%     & \Tarr{ \join{\tau_1}{\tau_2} }{ \join{\tau_1'}{\tau_2'} }
%     \\
%     \join{
%       \Trec{\pi_1}{\tau_1}
%     }{
%       \Trec{\pi_2}{\tau_2}
%     }
%     & \Trec{\join{\pi_1}{\pi_2}}{\join{\tau_1}{ \subst{\pi_1}{\pi_2}\tau_2} }}
%     \\
%     \join{
%       \Tsum{C_i(T_i)}_{C_i \in \TagSet}
%     }{
%       \Tsum{C_i(T_i')}_{C_i \in \TagSet}
%     }
%     & \Tsum{C_i(\join{T_i}{T_i'})}_{C_i \in \TagSet}
%     \\
%   \end{array}
% \]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% join(T1, T2) = T

% \Judgment{
%   \join{T_1}{T_2} = T
% }{
%   $T_1$ and $T_2$ join consistently, forming optional type $T$
% }

% \[
%   \join{T_1}{T_2} = \begin{cases}
%     \join{\tau_1}{\tau_2} & \text{when } T_1 = \tau_1 \wedge T_2 = \tau_2 \\
%     \Unit & \text{when } T_1 = T_2 = \Unit \\
%   \end{cases}
% \]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% join(pi1, pi2) = pi

% TODO: (eric) how to handle alpha-equivalence? (i.e. alpha1 != alpha2)

% \Judgment{
%   \join{\pi_1}{\pi_2} = \pi
% }{
%   $\pi_1$ and $\pi_2$ join consistently, forming type pattern $\pi$
% }

% \[
%   \arraycolsep=0pt
%   \begin{array}{l@{\quad=\quad}l@{\quad}l}
%     \join{ \alpha }{ \alpha } & \alpha \\
%     \join{ \hole{} }{ \alpha } & \alpha \\
%     \join{ \alpha }{ \hole{} } & \alpha \\
%   \end{array}
% \]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Theta |- tau valid

\Judgment{
  \valid{\Theta}{\tau}
}{
  $\tau$ is a valid type
}

\begin{mathpar}
  \inferrule[TVUnit]{
    %
  }{
    \valid{\Theta}{ \Unit }
  }

  \inferrule[TVArr]{
    \valid{\Theta}{\tau_1} \\
    \valid{\Theta}{\tau_2}
  }{
    \valid{\Theta}{ \Tarr{\tau_1}{\tau_2} }
  }

  \inferrule[TVVar]{
    \alpha \in \Theta
  }{
    \valid{\Theta}{ \alpha }
  }

  \inferrule[TVRec]{
    \valid{\Theta,\pi}{\tau}
  }{
    \valid{\Theta}{ \Trec{\pi}{\tau} }
  }

  \inferrule[TVSum]{
    \Set{ \valid{\Theta}{\tau_i} }_{C_i \in \TagSet}
  }{
    \valid{\Theta}{ \Tsum{ C_i(\tau_i) }_{C_i \in \TagSet} }
  }

  \inferrule[TVEHole]{
    %
  }{
    \valid{\Theta}{\hole{}}
  }
%
  % \inferrule[TVNEHole]{
  %   \alpha \notin \Theta
  % }{
  %   \valid{\Theta}{ \hole[\alpha]{} }
  % }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% tau ~ tau'

\Judgment{
  \consistent{\tau}{\tau'}
}{
  $\tau$ and $\tau'$ are consistent
}

\begin{mathpar}
  \inferrule[TCRefl]{
    %
  }{
    \consistent{\tau}{\tau}
  }

  \inferrule[TCEHole1]{
    %
  }{
    \consistent{\hole{}}{\tau}
  }

  \inferrule[TCEHole2]{
    %
  }{
    \consistent{\tau}{\hole{}}
  }

  \inferrule[TCNEHole1]{
    %
  }{
    \consistent{\hole[\alpha]{}}{\tau}
  }

  \inferrule[TCNEHole2]{
    %
  }{
    \consistent{\tau}{\hole[\alpha]{}}
  }

  \inferrule[TCArr]{
    \consistent{\tau_1}{\tau_1'} \\
    \consistent{\tau_2}{\tau_2'}
  }{
    \consistent{\Tarr{\tau_1}{\tau_2}}{\Tarr{\tau_1'}{\tau_2'}}
  }

  \inferrule[TCRec]{
    \consistent{\tau}{\tau'}
  }{
    \consistent{
      \Trec{\pi}{\tau}
    }{
      \Trec{\pi}{\tau'}
     }
  }

  \inferrule[TCRecHole1]{
    \alpha \notin \FV{\tau} \\
    \consistent{\tau}{\tau'}
  }{
    \consistent{
      \Trec{\hole{}}{\tau}
    }{
      \Trec{\alpha}{\tau'}
     }
  }

  \inferrule[TCRecHole2]{
    \alpha \notin \FV{\tau} \\
    \consistent{\tau}{\tau'}
  }{
    \consistent{
        \Trec{\alpha}{\tau}
      }{
        \Trec{\hole{}}{\tau'}
     }
  }

  \inferrule[TCSum]{
    \Set{ \consistent{\tau_i}{\tau_i'} }_{C_i \in \TagSet}
  }{
    \consistent{
      \Tsum{C_i(\tau_i)}_{C_i \in \TagSet}
    }{
      \Tsum{C_i(\tau_i')}_{C_i \in \TagSet}
    }
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  C valid

\Judgment{
  \validtag{C}
}{
  $C$ is a valid tag
}

\begin{mathpar}
  \inferrule[CVTag]{
    %
  }{
    \validtag{\Tag}
  }

  \inferrule[CVEHole]{
    %
  }{
    \validtag{\TagHole{u}}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  C ~ C'

% \Judgment{
%   \consistent{C}{C'}
% }{
%   $C$ and $C'$ are consistent
% }

% \begin{mathpar}
%   \inferrule[TagCRefl]{
%     %
%   }{
%     \consistent{C}{C}
%   }

%   \inferrule[TagCEHole1]{
%     %
%   }{
%     \consistent{\TagHole{u}}{C}
%   }

%   \inferrule[TagCEHole2]{
%     %
%   }{
%     \consistent{C}{\TagHole{u}}
%   }

%   \inferrule[TagCNEHole1]{
%     %
%   }{
%     \consistent{\TagHole[c]{u}}{C}
%   }

%   \inferrule[TagCNEHole2]{
%     %
%   }{
%     \consistent{C}{\TagHole[c]{u}}
%   }
% \end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Bidirectional Typing}

We call $\subst{\Trec{\pi}{\tau}}{\pi}{\tau}$ the \emph{unrolling} of recursive type $\Trec{\pi}{\tau}$.

\begin{Theorem}[Synthetic Type Validity]
  \label{thm:synthetic-type-validity}
  If $\syn{\Gamma}{e}{\tau}$ then $\valid{\emptyset}{\tau}$.
\end{Theorem}

\begin{Theorem}[Consistency Preserves Validity]
  \label{thm:valid-consistent-transitivity}
  If $\valid{\Theta}{\tau}$
  and $\consistent{\tau}{\tau'}$
  then $\valid{\Theta}{\tau'}$.
\end{Theorem}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  tau |> tau_1 -> tau_2

\Judgment{
  \MatchedArrowTyp{\tau}{\tau_1}{\tau_2}
}{
  $\tau$ has matched arrow type $\Tarr{\tau_1}{\tau_2}$
}

\begin{mathpar}
  \inferrule[MAHole]{
    %
  }{
    \MatchedArrowTyp{\hole{}}{\hole{}}{\hole{}}
  }

  \inferrule[MAArr]{
    %
  }{
    \MatchedArrowTyp{ \Tarr{\tau_1}{\tau_2} }{\tau_1}{\tau_2}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \MatchedRecTyp{\tau}{\pi}{\tau'}
}{
  $\tau$ has matched recursive type $\Trec{\pi}{\tau'}$
}

\begin{mathpar}
  \inferrule[MRRec]{
    %
  }{
    \MatchedRecTyp{ \Trec{\pi}{\tau} }{\pi}{\tau}
  }

  \inferrule[MRHole]{
    %
  }{
    \MatchedRecTyp{ \hole{} }{\hole{}}{\hole{}}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e => tau

\Judgment{
  \syn{\Gamma}{e}{\tau}
}{
  $e$ synthesizes type $\tau$
}

\begin{mathparpagebreakable}
  \inferrule[SUnit]{
    %
  }{
    \syn{\Gamma}{\Unit}{\Unit}
  }

  \inferrule[SVar]{
    \asc{x}{\tau} \in \Gamma
  }{
    \syn{\Gamma}{x}{\tau}
  }

  \inferrule[SVarFree]{
    x \notin \dom{\Gamma}
  }{
    \syn{\Gamma}{ \hole[x]{u} }{\hole{}}
  }

  \inferrule[SLam]{
    \valid{\emptyset}{\tau} \\
    \syn{\Gamma,\asc{x}{\tau}}{e}{\tau'}
  }{
    \syn{\Gamma}{ \Efun{x}{\tau}{e} }{\Tarr{\tau}{\tau'}}
  }

  \inferrule[SLamInvalid]{
    \syn{\Gamma, \asc{x}{\hole{}}}{e}{\tau}
  }{
    \syn{\Gamma}{ \Efun{x}{ \hole[\alpha]{} }{e} }{ \Tarr{\hole{}}{\tau} }
  }

  \inferrule[SApp]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \MatchedArrowTyp{\tau_1}{\tau_2}{\tau} \\
    \ana{\Gamma}{e_2}{\tau_2}
  }{
    \syn{\Gamma}{ \Eapp{e_1}{e_2} }{\tau}
  }

  \inferrule[SAppNotArr]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \notconsistent{\tau_1}{\Tarr{\hole{}}{\hole{}}} \\
    \ana{\Gamma}{e_2}{\hole{}}
  }{
    \syn{\Gamma}{ \Eapp{\mhole[e_1]{u}}{e_2} }{\hole{}}
  }

  \inferrule[SAsc]{
    \valid{\emptyset}{\tau} \\
    \ana{\Gamma}{e}{\tau}
  }{
    \syn{\Gamma}{ \asc{e}{\tau} }{\tau}
  }

  \inferrule[SAscInvalid]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \syn{\Gamma}{ \asc{e}{\hole[\alpha]{}} }{ \hole{} }
  }

  \inferrule[SRollErr]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \syn{\Gamma}{ \hole[ \Eroll{e} ]{u} }{ \Trec{\hole{}}{\hole{}} }
  }

  \inferrule[SUnroll]{
    \syn{\Gamma}{e}{ \tau } \\
    \MatchedRecTyp{\tau}{\pi}{\tau'}
  }{
    \syn{\Gamma}{ \Eunroll{e} }{\subst{ \Trec{\pi}{\tau'} }{\pi}{\tau'}}
  }

  \inferrule[SUnrollNotRec]{
    \syn{\Gamma}{e}{\tau} \\
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}}
  }{
    \syn{\Gamma}{ \Eunroll{\mhole[e]{u}} }{\hole{}}
  }

  \inferrule[SInjErr]{
    \validtag{C} \\
    \ana{\Gamma}{e}{\hole{}}
  }{
    \syn{\Gamma}{ \hole[ \Einj{C}{e} ]{u} }{\hole{}}
  }

  \inferrule[SInjTagErr]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \syn{\Gamma}{\Einj{\TagHole[c]{u}}{e}}{\hole{}}
  }

  % \inferrule[SCaseErr]{
  %   \ana{\Gamma}{e}{\hole{}} \\
  %   \Set{ \ana{\Gamma,\asc{X_i}{\hole{}}}{e_i}{\hole{}} }_{C_i \in \TagSet}
  % }{
  %   \syn{\Gamma}{ \hole[ \Ecase{e}{ C_i(X_i){=}e_i} ]{u} }{\hole{}}
  % }
  %
  \inferrule[SEHole]{
    %
  }{
    \syn{\Gamma}{ \hole{u} }{\hole{}}
  }

  \inferrule[SNEHole]{
    \syn{\Gamma}{e}{\tau}
  }{
    \syn{\Gamma}{ \hole[e]{u} }{\hole{}}
  }
\end{mathparpagebreakable}

% \textsc{SInj} = Injection in Synthetic Position or Analyzed Against Non-Sum

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e <= tau

\Judgment{
  \ana{\Gamma}{e}{\tau}
}{
  $e$ analyzes against type $\tau$
}

\begin{mathpar}
  \inferrule[ARoll]{
    \MatchedRecTyp{\tau}{\pi}{\tau'} \\
    \ana{\Gamma}{e}{ \subst{ \Trec{\pi}{\tau'} }{\pi}{\tau'} }
  }{
    \ana{\Gamma}{ \Eroll{e} }{\tau}
  }

  \inferrule[ARollNotRec]{
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}} \\
    \ana{\Gamma}{e}{ \hole{} }
  }{
    \ana{\Gamma}{ \hole[\Eroll{e}]{u} }{\tau}
  }

  \inferrule[AInjHole]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \ana{\Gamma}{ \Einj{C}{e} }{\hole{}}
  }

  \inferrule[AInj]{
    C_j \in \TagSet \\
    \ana{\Gamma}{e}{\tau_j}
  }{
    \ana{\Gamma}{ \Einj{C_j}{e} }{ \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} }
  }

  \inferrule[AInjUnexpectedBody]{
    C_j \in \TagSet \\
    \tau_j = \Unit \\
    e \neq \Unit \\
    \ana{\Gamma}{e}{\hole{}}
  }{
    \ana{\Gamma}{ \hole[\Einj{C_j}{e}]{u} }{\Tsum{C_i(\tau_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjExpectedBody]{
    C_j \in \TagSet \\
    \tau_j \neq \Unit
  }{
    \ana{\Gamma}{ \hole[\Einj{C_j}{\Unit}]{u} }{\Tsum{C_i(\tau_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjBadTag]{
    \validtag{C} \\
    C \notin \TagSet \\
    \ana{\Gamma}{e}{\hole{}}
  }{
    \ana{\Gamma}{
      \hole[\Einj{C}{e}]{u}
    }{\Tsum{C_i(\tau_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjTagErr]{
    \TagHole[c]{u} \notin \TagSet \\
    \ana{\Gamma}{e}{\hole{}}
  }{
    \ana{\Gamma}{ \Einj{\TagHole[c]{u}}{e} }{ \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} }
  }

  \inferrule[ASubsume]{
    \syn{\Gamma}{e}{\tau'} \\
    \consistent{\tau'}{\tau}
  }{
    \ana{\Gamma}{e}{\tau}
  }
\end{mathpar}

\subsection{Typed Elaboration}

\begin{Theorem}[Synthetic Typed Elaboration Validity]
  \label{thm:synthetic-typed-elaboration-validity}
  If $\synelab{\Gamma}{e}{\tau}{d}{\Delta}$ then $\valid{\emptyset}{\tau}$.
\end{Theorem}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e => tau ~> d -| Delta

\Judgment{
  \synelab{\Gamma}{e}{\tau}{d}{\Delta}
}{
  $e$ synthesizes type $\tau$ and elaborates to $d$
}

\begin{mathparpagebreakable}
  \inferrule[ESUnit]{
    %
  }{
    \synelab{\Gamma}{\Unit}{\Unit}{\Unit}{\emptyset}
  }

  \inferrule[ESVar]{
    \asc{x}{\tau} \in \Gamma
  }{
    \synelab{\Gamma}{x}{\tau}{x}{\emptyset}
  }

  \inferrule[ESVarFree]{
    x \notin \dom{\Gamma}
  }{
    \synelab{\Gamma}{
      \hole[x]{u}
    }{ \hole{} }{
      \dhole[x]{\id{\Gamma}}{u}
    }{u :: \hole{}[\Gamma]}
  }

  \inferrule[ESLam]{
    \valid{\emptyset}{\tau} \\
    \synelab{\Gamma, \asc{x}{\tau}}{e}{\tau'}{d}{\Delta}
  }{
    \synelab{\Gamma}{
      \Efun{x}{\tau}{e}
    }{ \Tarr{\tau}{\tau'} }{
      \Dfun{x}{\tau}{d}
    }{\Delta}
  }

  \inferrule[ESLamInvalid]{
    \synelab{\Gamma, \asc{x}{\hole{}}}{e}{\tau}{d}{\Delta}
  }{
    \synelab{\Gamma}{
      \Efun{x}{\hole[\alpha]{}}{e}
    }{ \Tarr{\hole{}}{\tau} }{
      \Dfun{x}{\hole[\alpha]{}}{d}
    }{\Delta}
  }

  \inferrule[ESApp]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \MatchedArrowTyp{\tau_1}{\tau_2}{\tau} \\
    \anaelab{\Gamma}{e_1}{ \Tarr{\tau_2}{\tau} }{d_1}{\tau_1'}{\Delta_1} \\
    \anaelab{\Gamma}{e_2}{ \tau_2 }{ d_2 }{\tau_2'}{\Delta_2}
  }{
    \synelab{\Gamma}{
      \Eapp{e_1}{e_2}
    }{ \tau }{
      \Dapp{
        \left( \cast{d_1}{\tau_1'}{\tau_1} \right)
      }{
        \cast{d_2}{\tau_2'}{\tau_2}
      }
    }{ \Delta_1 \cup \Delta_2 }
  }

  \inferrule[ESAppNotArr]{
    \synelab{\Gamma}{e_1}{\tau_1}{d_1}{\Delta_1} \\
    \notconsistent{\tau_1}{\Tarr{ \hole{} }{ \hole{} }} \\
    \anaelab{\Gamma}{e_2}{ \hole{} }{ d_2 }{\tau_2'}{\Delta_2}
  }{
    \synelab{\Gamma}{
      \Eapp{ \mhole[e_1]{u} }{e_2}
    }{ \hole{} }{
      \Dapp{
        \mhole[d_1]{u}_{\id{\Gamma}}
      }{
        \cast{d_2}{\tau_2'}{ \hole{} }
      }
    }{ \Delta_1 \cup \Delta_2, u :: \Tarr{ \hole{} }{ \hole{} } [\Gamma]}
  }

  \inferrule[ESAsc]{
    \valid{\emptyset}{\tau} \\\\
    \anaelab{\Gamma}{e}{\tau}{d}{\tau'}{\Delta}
  }{
    \synelab{\Gamma}{
      \asc{e}{\tau}
    }{ \tau }{
      \cast{d}{\tau'}{\tau}
    }{\Delta}
  }

  \inferrule[ESAscInvalid]{
    \anaelab{\Gamma}{e}{\hole{}}{d}{\tau}{\Delta}
  }{
    \synelab{\Gamma}{
      \asc{e}{\hole[\alpha]{}}
    }{ \hole{} }{
      \cast{d}{\tau}{\hole{}}
    }{\Delta}
  }

  \inferrule[ESRollErr]{
    \anaelab{\Gamma}{
      e
    }{ \hole{}}{
      d
    }{ \tau }{\Delta}
  }{
    \synelab{\Gamma}{
      \hole[ \Eroll{e} ]{u}
    }{ \Trec{ \hole{} }{ \hole{} }}{
      \hole[ \Droll{ \hole{} }{ \hole{} }{ \cast{d}{\tau}{\hole{}} } ]{u}_{\id{\Gamma}}
    }{\Delta, u :: \Trec{ \hole{} }{ \hole{} }[\Gamma]}
  }

  \inferrule[ESUnroll]{
    \synelab{\Gamma}{e}{\tau}{d}{\Delta} \\
    \MatchedRecTyp{\tau}{\pi}{\tau'}
  }{
    \synelab{\Gamma}{
      \Eunroll{e}
    }{ \subst{\Trec{\pi}{\tau'}}{\pi}{\tau'} }{
      \Dunroll{ \cast{d}{\tau}{\Trec{\pi}{\tau'}} }
    }{\Delta}
  }

  \inferrule[ESUnrollNotRec]{
    \synelab{\Gamma}{e}{\tau}{d}{\Delta} \\
    \notconsistent{\tau}{\Trec{ \hole{} } { \hole{} }}
  }{
    \synelab{\Gamma}{
      \Eunroll{ \mhole[e]{u} }
    }{ \hole{} }{
      \Dunroll{ \mhole[d]{u}_{\id{\Gamma}} }
    }{\Delta, u :: \Trec{\hole{}}{\hole{}}[\Gamma]}
  }

  \inferrule[ESInjErr]{
    \validtag{C} \\
    \anaelab{\Gamma}{e}{\hole{}}{d}{\tau}{\Delta} \\
    \tau' = \Tsum{C(\tau)} \\
  }{
    \synelab{\Gamma}{
      \hole[ \Einj{C}{e} ]{u}
    }{ \hole{} }{
      \dhole[
        \Dinj{C}{ \tau' }{ \cast{d}{\tau}{\hole{}} }
      ]{\id{\Gamma}}{u}
    }{\Delta, u :: \hole{}[\Gamma]}
  }

  \inferrule[ESInjTagErr]{
    \anaelab{\Gamma}{e}{\hole{}}{d}{\tau}{\Delta} \\
    \tau' = \Tsum{\TagHole[c]{u}(\tau)}
  }{
    \synelab{\Gamma}{
      \Einj{\TagHole[c]{u}}{e}
    }{\hole{}}{
      \Dinj{\TagHole[c]{u}}{\tau'}{ \cast{d}{\tau}{\hole{}} }
    }{\Delta}
  }

  \inferrule[ESEHole]{
    %
  }{
    \synelab{\Gamma}{
      \hole{u}
    }{ \hole{} }{
      \dhole{\id{\Gamma}}{u}
    }{u :: \hole{}[\Gamma]}
  }

  \inferrule[ESNEHole]{
    \synelab{\Gamma}{e}{\tau}{d}{\Delta}
  }{
    \synelab{\Gamma}{
      \hole[e]{u}
    }{ \hole{} }{
      \dhole[d]{\id{\Gamma}}{u}
    }{ \Delta, u :: \hole{}[\Gamma]}
  }
\end{mathparpagebreakable}

% TODO: define D<T => T>

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e <= tau_1 ~> d : tau_2 -| Delta

\Judgment{
  \anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}
}{
  $e$ analyzes against type $\tau_1$ and elaborates to $d$ of consistent type $\tau_2$
}

\begin{mathparpagebreakable}
  \inferrule[EARoll]{
    \MatchedRecTyp{\tau}{\pi}{\tau'} \\
    \anaelab{\Gamma}{
      e
    }{ \subst{\Trec{\pi}{\tau'}}{\pi}{\tau'} }{
      d
    }{\tau''}{\Delta}
  }{
    \anaelab{\Gamma}{
      \Eroll{e}
    }{ \tau }{
      \Droll{\pi}{\tau'}{
        \cast{d}{\tau''}{ \subst{\Trec{\pi}{\tau'}}{\pi}{\tau'} }
      }
    }{ \Trec{\pi}{\tau'} }{ \Delta }
  }

  \inferrule[EARollNotRec]{
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}} \\
    \anaelab{\Gamma}{e}{\hole{}}{d}{\tau'}{\Delta}
  }{
    \anaelab{\Gamma}{
      \hole[ \Eroll{e} ]{u}
    }{\tau}{
      \dhole[ \Droll{\hole{}}{\hole{}}{d} ]{\id{\Gamma}}{u}
    }{ \Trec{\hole{}}{\hole{}} }{ \Delta, u :: \Trec{\hole{}}{\hole{}}[\Gamma] }
  }

  \inferrule[EAInjHole]{
    \anaelab{\Gamma}{e}{ \hole{} }{d}{\tau}{\Delta} \\
    \tau' = \Tsum{C(\tau)}
  }{
    \anaelab{\Gamma}{
      \Einj{C}{e}
    }{ \hole{} }{
      \Dinj{C}{\tau'}{d}
    }{\tau'}{\Delta}
  }

  \inferrule[EAInj]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    \anaelab{\Gamma}{e}{\tau_j}{d}{\tau_j'}{\Delta}
  }{
    \anaelab{\Gamma}{
      \Einj{C_j}{e}
    }{\tau}{
      \Dinj{C_j}{\tau}{ \cast{d}{\tau_j'}{\tau_j} }
    }{\tau}{\Delta}
  }

  \inferrule[EAInjUnexpectedBody]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    \tau_j = \Unit \\
    e \neq \Unit \\\\
    \anaelab{\Gamma}{e}{ \hole{} }{ d }{ \tau_j }{\Delta} \\
    \tau' = \Tsum{\Set{C_i(\tau_i)}_{C_i \in \TagSet \setminus C_j} \cup \Set{C_j(\tau_j)}}
  }{
    \anaelab{\Gamma}{
      \hole[ \Einj{C_j}{e} ]{u}
    }{\tau}{
      \dhole[ \Dinj{C_j}{\tau'}{d} ]{\id{\Gamma}}{u}
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjExpectedBody]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    \tau_j \neq \Unit \\
    \tau' = \Tsum{\Set{C_i(\tau_i)}_{C_i \in \TagSet \setminus C_j} \cup \Set{C_j(\Unit)}}
  }{
    \anaelab{\Gamma}{
      \hole[ \Einj{C_j}{\Unit} ]{u}
    }{\tau}{
      \dhole[ \Dinj{C_j}{\tau'}{\Unit} ]{\id{\Gamma}}{u}
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjBadTag]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\
    C \notin \TagSet \\
    \validtag{C} \\
    \anaelab{\Gamma}{e}{ \hole{} }{d}{\tau'}{\Delta} \\
    \tau'' = \Tsum{\Set{C_i(\tau_i)}_{C_i \in \TagSet} \cup \Set{C(\tau')}}
  }{
    \anaelab{\Gamma}{
      \hole[ \Einj{C}{e} ]{u}
    }{\tau}{
      \dhole[ \Dinj{C}{\tau''}{d} ]{\id{\Gamma}}{u}
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjTagErr]{
    \TagHole[c]{u} \notin \TagSet \\
    \anaelab{\Gamma}{e}{\hole{}}{d}{\tau}{\Delta} \\
    \tau' = \Tsum{\Set{C_i(\tau_i)}_{C_i \in \TagSet} \cup \Set{\TagHole[c]{u}(\tau)}}
  }{
    \anaelab{\Gamma}{
      \Einj{\TagHole[c]{u}}{e}
    }{ \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} }{
      \Dinj{\TagHole[c]{u}}{\tau'}{ \cast{d}{\tau}{\hole{}} }
    }{ \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} }{ \Delta }
  }

  \inferrule[EASubsume]{
    e \neq \hole{u} \\
    e \neq \hole[e']{u} \\
    \synelab{\Gamma}{e}{\tau'}{d}{\Delta} \\
    \consistent{\tau}{\tau'}
  }{
    \anaelab{\Gamma}{e}{\tau}{d}{\tau'}{\Delta}
  }

  \inferrule[EAEHole]{
    %
  }{
    \anaelab{\Gamma}{
      \hole{u}
    }{ \tau }{
      \dhole{\id{\Gamma}}{u}
    }{\tau}{u :: \tau[\Gamma]}
  }

  \inferrule[EANEHole]{
    \synelab{\Gamma}{e}{\tau'}{d}{\Delta}
  }{
    \anaelab{\Gamma}{
      \hole[e]{u}
    }{ \tau }{
      \dhole[d]{\id{\Gamma}}{u}
    }{\tau}{u :: \tau[\Gamma]}
  }
\end{mathparpagebreakable}

\subsection{Type Assignment}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Delta; Gamma |- d : tau

\Judgment{
  \assign{\Delta}{\Gamma}{d}{\tau}
}{
  $d$ is assigned type $\tau$
}

\begin{mathpar}
  \inferrule[TAUnit]{
    %
  }{
    \assign{\Delta}{\Gamma}{\Unit}{\Unit}
  }

  \inferrule[TAVar]{
    \asc{x}{\tau} \in \Gamma
  }{
    \assign{\Delta}{\Gamma}{ x }{ \tau }
  }

  \inferrule[TALam]{
    \tau \neq \hole[\alpha]{} \\
    \assign{\Delta}{\Gamma, \asc{x}{\tau}}{ d }{ \tau' }
  }{
    \assign{\Delta}{\Gamma}{ \Dfun{x}{\tau}{d} }{ \Tarr{\tau}{\tau'} }
  }

  \inferrule[TALamFree]{
    \assign{\Delta}{\Gamma, \asc{x}{\hole{}}}{ d }{ \tau }
  }{
    \assign{\Delta}{\Gamma}{ \Dfun{x}{\hole[\alpha]{}}{d} }{ \Tarr{\hole{}}{\tau} }
  }

  \inferrule[TAApp]{
    \assign{\Delta}{\Gamma}{ d_1 }{ \Tarr{\tau_2}{\tau} } \\
    \assign{\Delta}{\Gamma}{ d_2 }{ \tau_2 }
  }{
    \assign{\Delta}{\Gamma}{ \Dapp{d_1}{d_2} }{ \tau }
  }

  \inferrule[TARoll]{
    \valid{\emptyset}{\Trec{\pi}{\tau}} \\
    \assign{\Delta}{\Gamma}{ d }{ \subst{\Trec{\pi}{\tau}}{\pi}{\tau} }
  }{
    \assign{\Delta}{\Gamma}{ \Droll{\pi}{\tau}{d} }{ \Trec{\pi}{\tau} }
  }

  \inferrule[TAUnroll]{
    \assign{\Delta}{\Gamma}{ d }{ \Trec{\pi}{\tau} }
  }{
    \assign{\Delta}{\Gamma}{ \Dunroll{d} }{ \subst{\Trec{\pi}{\tau}}{\pi}{\tau} }
  }

  \inferrule[TAInj]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    \assign{\Delta}{\Gamma}{ d }{ \tau_j }
  }{
    \assign{\Delta}{\Gamma}{ \Dinj{C_j}{\tau}{d} }{ \tau }
  }

  \inferrule[TAEHole]{
    u :: \tau[\Gamma'] \in \Delta \\
    \assign{\Delta}{\Gamma}{ \sigma }{ \Gamma' }
  }{
    \assign{\Delta}{\Gamma}{ \dhole{\sigma}{u} }{ \tau }
  }

  \inferrule[TANEHole]{
    \assign{\Delta}{\Gamma}{ d }{ \tau' } \\
    u :: \tau[\Gamma'] \in \Delta \\
    \assign{\Delta}{\Gamma}{ \sigma }{ \Gamma' }
  }{
    \assign{\Delta}{\Gamma}{ \dhole[d]{\sigma}{u} }{ \tau }
  }

  \inferrule[TAMHole]{
    \assign{\Delta}{\Gamma}{ d }{ \tau' } \\
    u :: \tau[\Gamma'] \in \Delta \\
    \assign{\Delta}{\Gamma}{ \sigma }{ \Gamma' }
  }{
    \assign{\Delta}{\Gamma}{ \mhole[d]{u}_{\sigma} }{ \tau }
  }

  \inferrule[TACast]{
    \assign{\Delta}{\Gamma}{ d }{ \tau_1 } \\
    \consistent{\tau_1}{\tau_2}
  }{
    \assign{\Delta}{\Gamma}{ \cast{d}{\tau_1}{\tau_2} }{ \tau_2 }
  }

  \inferrule[TAFailedCast]{
    \assign{\Delta}{\Gamma}{ d }{ \tau_1 } \\
    \ground{\tau_1} \\
    \ground{\tau_2} \\
    \tau_1 \neq \tau_2
  }{
    \assign{\Delta}{\Gamma}{ \failedcast{d}{\tau_1}{\tau_2} }{ \tau_2 }
  }
%
%   \inferrule[TCase]{
%     \assign{\Delta}{\Gamma}{d}{\Tsum{C_i(T_i)}_{C_i \in \TagSet}} \\
%     \assign{\Delta}{\Gamma, X_i : T_i}{d_i}{\tau} \\
%     i = 1, \ldots, N
%   }{
%     \assign{\Delta}{\Gamma}{
%       \case{d}{C_i(X_i){=}d_i}_{C_i \in \TagSet}
%     }{\tau}
%   }
%
%   \inferrule[TCaseU]{
%     \assign{\Delta}{\Gamma}{d}{\hole} \\
%     \assign{\Delta}{\Gamma, X_i : \hole}{d_i}{\tau} \\
%     i = 1, \ldots, N
%   }{
%     \assign{\Delta}a{\Gamma}{\case{d}{C_i(X_i){=}{d_i}}_{C_i \in \TagSet}}{\tau}
%   }
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dynamic Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% tau ground

\Judgment{
  \ground{\tau}
}{
  $\tau$ is a ground type
}

\begin{mathpar}
  \inferrule[GArr]{
  }{
    \ground{ \Tarr{\hole{}}{\hole{}} }
  }

  \inferrule[GRec]{
  }{
    \ground{ \Trec{\hole{}}{\hole{}} }
  }

  \inferrule[GSum]{
    \Set{\tau_i = \Unit \vee \tau_i = \hole{}}_{C_i \in \TagSet}
  }{
    \ground{ \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} }
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \MatchedGroundTyp{\tau}{\tau'}
}{
  $\tau$ has matched ground type $\tau'$
}

\begin{mathpar}
  \inferrule[MGArr]{
    \Tarr{\tau_1}{\tau_2} \neq \Tarr{\hole{}}{\hole{}}
  }{
    \MatchedGroundTyp{ \Tarr{\tau_1}{\tau_2} }{ \Tarr{\hole{}}{\hole{}} }
  }

  \inferrule[MGRec]{
    \tau \neq \hole{}
  }{
    \MatchedGroundTyp{ \Trec{\pi}{\tau} }{ \Trec{\hole{}}{\hole{}} }
  }

  \inferrule[MGSum]{
    \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \neq \Tsum{C_i(\tau_i')}_{C_i \in \TagSet} \\
    \Set{
      \left( \tau_i   =  \Unit \implies \tau_i' = \Unit   \right) \wedge
      \left( \tau_i \neq \Unit \implies \tau_i' = \hole{} \right)
    }_{C_i \in \TagSet}
  }{
    \MatchedGroundTyp{
      \Tsum{C_i(\tau_i)}_{C_i \in \TagSet}
    }{
      \Tsum{C_i(\tau_i')}_{C_i \in \TagSet}
    }
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \final{d}
}{
  $d$ is final
}

\begin{mathpar}
  \inferrule[FBoxedVal]{
    \boxedval{d}
  }{
    \final{d}
  }

  \inferrule[FIndet]{
    \indet{d}
  }{
    \final{d}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \val{d}
}{
  $d$ is a value
}

\begin{mathpar}
  \inferrule[VUnit]{
    %
  }{
    \val{ \Unit }
  }

  \inferrule[VLam]{
    %
  }{
    \val{ \Dfun{x}{\tau}{d} }
  }

  \inferrule[VRoll]{
    \val{d}
  }{
    \val{ \Droll{\pi}{\tau}{d} }
  }

  \inferrule[VInj]{
    \val{d}
  }{
    \val{ \Dinj{\Tag}{\tau}{d} }
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \boxedval{d}
}{
  $d$ is a boxed value
}

\begin{mathpar}
  \inferrule[BVVal]{
    \val{d}
  }{
    \boxedval{d}
  }

  \inferrule[BVRoll]{
    \boxedval{d}
  }{
    \boxedval{\Droll{\pi}{\tau}{d}}
  }

  \inferrule[BVInj]{
    \boxedval{d}
  }{
    \boxedval{\Dinj{\Tag}{\tau}{d}}
  }

  \inferrule[BVArrCast]{
    \Tarr{\tau_1}{\tau_2} \neq \Tarr{\tau_3}{\tau_4} \\
    \boxedval{d}
  }{
    \boxedval{
      \cast{d}{
        \Tarr{\tau_1}{\tau_2}
      }{
        \Tarr{\tau_3}{\tau_4}
      }
    }
  }

  \inferrule[BVRecCast]{
    \Trec{\pi}{\tau} \neq \Trec{\pi'}{\tau'} \\
    \boxedval{d}
  }{
    \boxedval{\cast{d}{ \Trec{\pi}{\tau} }{ \Trec{\pi'}{\tau'} }}
  }

  \inferrule[BVSumCast]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\\\
    \tau' = \Tsum{C_i(\tau_i')}_{C_i \in \TagSet} \\\\
    \tau \neq \tau' \\
    \boxedval{d}
  }{
    \boxedval{ \cast{d}{\tau}{\tau'} }
  }

  \inferrule[BVHoleCast]{
    \boxedval{d} \\
    \ground{\tau}
  }{
    \boxedval{ \cast{d}{\tau}{\hole{}} }
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \indet{d}
}{
  $d$ is indeterminate
}

\begin{mathpar}
  \inferrule[IEHole]{
    %
  }{
    \indet{\dhole{\sigma}{u}}
  }

  \inferrule[INEHole]{
    \final{d}
  }{
    \indet{\dhole[d]{\sigma}{u}}
  }

  \inferrule[IApp]{
    d_1 \neq \cast{d_1'}{\Tarr{\tau_1}{\tau_2}}{\Tarr{\tau_3}{\tau_4}} \\
    \indet{d_1} \\
    \final{d_2}
  }{
    \indet{\Dapp{d_1}{d_2}}
  }

  \inferrule[IRoll]{
    \indet{d}
  }{
    \indet{\Droll{\pi}{\tau}{d}}
  }

  \inferrule[IUnroll]{
    \indet{d}
  }{
    \indet{\Dunroll{d}}
  }

  \inferrule[IInj]{
    \indet{d}
  }{
    \indet{\Dinj{\Tag}{\tau}{d}}
  }

  \inferrule[IInjHole]{
    C \neq \Tag \\
    \final{d}
  }{
    \indet{\Dinj{C}{\tau}{d}}
  }

  \inferrule[ICastGroundHole]{
    \indet{d} \\
    \ground{\tau}
  }{
    \indet{\cast{d}{\tau}{\hole{}}}
  }

  \inferrule[ICastHoleGround]{
    d \neq \cast{d'}{\tau'}{\hole{}} \\
    \indet{d} \\
    \ground{\tau}
  }{
    \indet{\cast{d}{\hole{}}{\tau}}
  }

  \inferrule[ICastArr]{
    \Tarr{\tau_1}{\tau_2} \neq \Tarr{\tau_3}{\tau_4} \\
    \indet{d}
  }{
    \indet{\cast{d}{\Tarr{\tau_1}{\tau_2}}{\Tarr{\tau_3}{\tau_4}}}
  }

  \inferrule[ICastRec]{
    \Trec{\pi}{\tau} \neq \Trec{\pi'}{\tau'} \\
    \indet{d}
  }{
    \indet{
      \cast{d}{
        \Trec{\pi}{\tau}
      }{
        \Trec{\pi'}{\tau'}
      }
    }
  }

  \inferrule[ICastSum]{
    \tau = \Tsum{C_i(\tau_i)}_{C_i \in \TagSet} \\\\
    \tau' = \Tsum{C_i(\tau_i')}_{C_i \in \TagSet} \\\\
    \tau \neq \tau' \\
    \indet{d}
  }{
    \indet{ \cast{d}{\tau}{\tau'} }
  }

  \inferrule[IFailedCast]{
    \final{d} \\
    \ground{\tau_1} \\
    \ground{\tau_2} \\
    \tau_1 \neq \tau_2
  }{
    \indet{\failedcast{d}{\tau_1}{\tau_2}}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \trans{d}{d'}
}{
  $d$ takes an instruction transition to $d'$
}

\begin{mathparpagebreakable}
  \inferrule[ITApp]{
    \eager{\final{d_2}}
  }{
    \trans{  
      \Dapp{ \left( \Dfun{x}{\tau}{d_1} \right) }{ d_2 }
    }{
      \subst{d_2}{x}{d_1}
    }
  }

  \inferrule[ITUnroll]{
    \eager{\final{d}}
  }{
    \trans{
      \Dunroll{\Droll{\pi}{\tau}{d}}
    }{
      d
    }
  }

  \inferrule[ITAppCast]{
    \eager{\final{d_1}} \\
    \eager{\final{d_2}} \\
    \Tarr{\tau_1}{\tau_2} \neq \Tarr{\tau_1'}{\tau_2'}
  }{
    \trans{
      \Dapp{
        \cast{d_1}{ \Tarr{\tau_1}{\tau_2} }{ \Tarr{\tau_1'}{\tau_2'} }
      }{
        d_2
      }
    }{
      \cast{
        \left( \Dapp{d_1}{ \cast{d_2}{\tau_1'}{\tau_1} } \right)
      }{\tau_2}{\tau_2'}
    }
  }

  \inferrule[ITUnrollCast]{
    \eager{\final{d}} \\
    \Trec{\pi}{\tau} \neq \Trec{\pi'}{\tau'}
  }{
    \trans{
      \Dunroll{ \cast{d}{\Trec{\pi}{\tau}}{\Trec{\pi'}{\tau'}} }
    }{
      \cast{ \Dunroll{d} }{ \subst{\Trec{\pi}{\tau}}{\pi}{\tau} }{ \subst{\Trec{\pi'}{\tau'}}{\pi'}{\tau'} }
    }
  }

  \inferrule[ITCastId]{
    \eager{\final{d}}
  }{
    \trans{ \cast{d}{\tau}{\tau} }{ d }
  }

  \inferrule[ITCastSucceed]{
    \eager{\final{d}} \\
    \ground{\tau}
  }{
    \trans{ \casts{d}{\tau}{\hole{}}{\tau} }{ d }
  }

  \inferrule[ITCastFail]{
    \eager{\final{d}} \\
    \tau_1 \neq \tau_2 \\
    \ground{\tau_1} \\
    \ground{\tau_2}
  }{
    \trans{
      \casts{d}{\tau_1}{\hole{}}{\tau_2}
    }{
      \failedcast{d}{\tau_1}{\tau_2}
    }
  }

  \inferrule[ITGround]{
    \eager{\final{d}} \\
    \MatchedGroundTyp{\tau}{\tau'}
  }{
    \trans{
      \cast{d}{\tau}{\hole{}}
    }{
      \casts{d}{\tau}{\tau'}{\hole{}}
    }
  }

  \inferrule[ITExpand]{
    \eager{\final{d}} \\
    \MatchedGroundTyp{\tau}{\tau'}
  }{
    \trans{
      \cast{d}{\hole{}}{\tau}
    }{
      \casts{d}{\hole{}}{\tau'}{\tau}
    }
  }
\end{mathparpagebreakable}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\[
  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \EvalCtx & \E & {}\Coloneqq{} &
      \Mark
      \mid \Dapp{\E}{d}
      \mid \Dapp{d}{\E}
      \mid \Droll{\pi}{\tau}{\E}
      \mid \Dunroll{\E}
      \mid \Dinj{C}{\tau}{\E}
      \mid \dhole[\E]{\sigma}{u}
      \mid \dmhole[\E]{\sigma}{u}
      \\ &&&
      \mid \cast{\E}{\tau}{\tau}
      \mid \failedcast{\E}{\tau}{\tau}
      \\
  \end{array}
\]

\Judgment{
  \eval{d}{\E}{d'}
}{
  $d$ is obtained by placing $d'$ at the mark in $\E$
}

\begin{mathpar}
  \inferrule[FHOuter]{
    %
  }{
    \eval{d}{\Mark}{d}
  }

  \inferrule[FHApp1]{
    \eval{d_1}{\E}{d_1'}
  }{
    \eval{ \Dapp{d_1}{d_2} }{ \Dapp{\E}{d_2} }{d_1'}
  }

  \inferrule[FHApp2]{
    \eager{\final{d_1}} \\
    \eval{d_2}{\E}{d_2'}
  }{
    \eval{ \Dapp{d_1}{d_2} }{ \Dapp{d_1}{\E} }{ d_2' }
  }

  \inferrule[FHRoll]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \Droll{\pi}{\tau}{d}
    }{\Droll{\pi}{\tau}{\E}
    }{d'}
  }

  \inferrule[FHUnroll]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \Dunroll{d}
    }{\Dunroll{\E}
    }{d'}
  }

  \inferrule[FHInj]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \Dinj{C}{\tau}{d}
    }{\Dinj{C}{\tau}{\E}
    }{d'}
  }

  \inferrule[FNEHoleInside]{
    \eval{d}{\E}{d'}
  }{
    \eval{ \dhole[d]{\sigma}{u} }{ \dhole[\E]{\sigma}{u} }{ d' }
  }

  \inferrule[FMHoleInside]{
    \eval{d}{\E}{d'}
  }{
    \eval{ \mhole[d]{u}_\sigma }{ \mhole[\E]{u}_\sigma }{ d' }
  }

  \inferrule[FHCastInside]{
    \eval{d}{\E}{d'}
  }{
    \eval{ \cast{d}{\tau_1}{\tau_2} }{ \cast{\E}{\tau_1}{\tau_2} }{ d' }
  }

  \inferrule[FHFailedCast]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \failedcast{d}{\tau_1}{\tau_2}
    }{
      \failedcast{\E}{\tau_1}{\tau_2}
    }{d'}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \step{d}{d'}
}{
  $d$ steps to $d'$
}

\begin{mathpar}
  \inferrule[Step]{
    \eval{d}{\E}{d_0} \\
    \trans{d_0}{d_0'} \\
    \eval{d'}{\E}{d_0'}
  }{
    \step{d}{d'}
  }
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}