\documentclass{article}

\usepackage{fullpage}
\usepackage{amsmath, stmaryrd, amssymb, mathtools, mathpartir}

% fix spacing between math operators and large paired delimiters
\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}

% Theorems and Proofs

\usepackage{amsthm}
\newtheorem{Theorem}{Theorem}
\newtheorem{Lemma}[Theorem]{Lemma}

\usepackage{pfsteps}
\renewcommand\byCasesEveryCase{}
\setlength{\proofrightwidth}{0.4\linewidth}

% Sets

\newcommand{\Set}[1]{\left\{#1\right\}}

% Sorts

\newcommand\Sort[1]{\mathsf{#1}}

\newcommand\IHExp{\Sort{IHExp}}
\newcommand\IHTagArg{\Sort{IHTagArg}}
\newcommand\HExp{\Sort{HExp}}
\newcommand\HExpPat{\Sort{HExpPat}}
\newcommand\HTag{\Sort{HTag}}
\newcommand\HTagArg{\Sort{HTagArg}}
\newcommand\HTagTyp{\Sort{HTagTyp}}
\newcommand\HTagVar{\Sort{HTagVar}}
\newcommand\HTyp{\Sort{HTyp}}
\newcommand\HTypPat{\Sort{HTypPat}}
\newcommand\EvalCtx{\Sort{EvalCtx}}

% Holes

\newcommand\hole[2][]{\llparenthesis#1\rrparenthesis^{#2}}
\newcommand\dhole[3][]{\llparenthesis#1\rrparenthesis_{#2}^{#3}}

% Types

\newcommand\Tarrow[2]{#1 \rightarrow #2}
\newcommand\Trec[2]{\mu{#1}.{#2}}
\newcommand\Tsum[1]{+\mathopen{}\left\{#1\right\}}

% Tags

\newcommand\Tag{\mathbf{C}}
\newcommand\TagSet{\mathcal{C}}

% Optional Tag Arguments

\newcommand\None{\varnothing}

% Token Literals

\newcommand\literal[1]{\mathtt{#1}}

% Type Ascription

\newcommand\asc[2]{{#1}:{#2}}

% External Expressions

\newcommand\Efun[3]{\lambda{#1}{:}{#2}.{#3}}
\newcommand\Eapp[2]{{#1}\left({#2}\right)}
\newcommand\Einj[2]{\literal{inj}_{#1}\left({#2}\right)}
\newcommand\Ecase[2]{\literal{case} \left({#1}\right) \left\{{#2}\right\}}
\newcommand\Eroll[1]{\literal{roll}\left(#1\right)}
\newcommand\Eunroll[1]{\literal{unroll}\left(#1\right)}

% Internal Expressions

\newcommand\Dfun[3]{\lambda{#1}{:}{#2}.{#3}}
\newcommand\Dapp[2]{{#1}\left({#2}\right)}
\newcommand\Dinj[3]{\literal{inj}_{#1}^{#2}\left({#3}\right)}
\newcommand\Dcase[2]{\literal{case} \left({#1}\right) \left\{{#2}\right\}}
\newcommand\Droll[3]{\literal{roll}^{\Trec{#1}{#2}}\left({#3}\right)}
\newcommand\Dunroll[1]{\literal{unroll}\left(#1\right)}
\newcommand\cast[3]{{#1}\langle{#2}\Rightarrow{#3}\rangle}
\newcommand\casts[4]{{#1}\langle{#2}\Rightarrow{#3}\Rightarrow{#4}\rangle}
\newcommand\failedcast[3]{{#1}\langle{#2}\Rightarrow{\llparenthesis\rrparenthesis}\nRightarrow{#3}\rangle}

% Judgments

\newcommand\Judgment[2]{\noindent{}$\boxed{#1}$\quad{#2}}
\newcommand\judgment[1]{\mathrm{#1}}

\newcommand\syn[3]{{#1}\vdash{#2}\Rightarrow{#3}}
\newcommand\ana[3]{{#1}\vdash{#2}\Leftarrow{#3}}

\newcommand\synelab[5]{#1 \vdash #2 \Rightarrow #3 \leadsto #4 \dashv #5}
\newcommand\anaelab[6]{#1 \vdash #2 \Leftarrow #3 \leadsto #4 : #5 \dashv #6}

\newcommand\assign[4]{#1; #2 \vdash #3 : #4}
\newcommand\ground[1]{#1~\judgment{ground}}
\newcommand\join[2]{\mathsf{join}\left(#1,#2\right)}
\newcommand\val[1]{#1~\judgment{val}}
\newcommand\boxedval[1]{#1~\judgment{boxedval}}
\newcommand\indet[1]{#1~\judgment{indet}}
\newcommand\final[1]{#1~\judgment{final}}
\newcommand\eval[3]{#1 = #2\left\{#3\right\}}

% Helpers

\newcommand\helper[1]{\mathsf{#1}}

\newcommand\consistent[2]{{#1}\sim{#2}}
\newcommand\notconsistent[2]{{#1}\nsim{#2}}
\newcommand\valid[2]{{#1}\vdash{#2}\,\helper{valid}}
% \newcommand\ValidExp[3]{{#1};{#2}\vdash{#3}\,\helper{valid}}
\newcommand\FV[1]{\helper{FV}\left(#1\right)}
\newcommand\id[1]{\helper{id}\left(#1\right)}

% Matched Types

\newcommand\MatchedArrowTyp[3]{{#1}\blacktriangleright_\rightarrow{#2}\rightarrow{#3}}
\newcommand\MatchedRecTyp[3]{{#1}\blacktriangleright_\mu\Trec{#2}{#3}}
\newcommand{\MatchedGroundTyp}[2]{#1 \blacktriangleright_{\helper{ground}} #2}

% Substitution

\newcommand\subst[3]{\left[{#1}/{#2}\right]{#3}}

% Evaluation

\newcommand\E{\mathcal{E}}

% Operations
% \newcommand{\defeq}{\stackrel{\text{def}}{=}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Algebraic Data Types for Hazel}
\author{Eric Griffis \\ egriffis@umich.edu}
\date{}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Syntax}

\[
  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \HTyp & \tau & \Coloneqq &
      \Tarrow{\tau}{\tau}
      \mid \alpha
      \mid \Trec{\pi}{\tau}
      \mid \Tsum{C_i(T_i)}_{C_i \in \TagSet}
      \mid \hole{}
      \mid \hole[\alpha]{u}
      \\
    \HTypPat & \pi & \Coloneqq & \alpha \mid \hole{} \\
    \HExp & e & \Coloneqq &
      x
      \mid \Efun{x}{\tau}{e}
      \mid \Eapp{e}{e}
      \mid \asc{e}{\tau}
      \mid \Einj{C}{E}
      % \mid \Ecase{e}{C_i(X_i){=}e_i}_{C_i \in \TagSet}
      \mid \Eroll{e}
      \mid \Eunroll{e}
      \\ & & &
      \mid \hole{u}
      \mid \hole[e]{u}
      \\
    \HTagTyp & T & \Coloneqq & \tau \mid \None \\
    \HTagArg & E & \Coloneqq & e \mid \None \\
    % \HTagVar & X & \Coloneqq & x \mid \None \\
    \IHExp & d & \Coloneqq &
      x
      \mid \Dfun{x}{\tau}{d}
      \mid \Dapp{d}{d}
      \mid \Dinj{C}{\tau}{D}
      % \mid \Dcase{d}{C_i(X_i)}_{C_u \in \TagSet}
      \mid \Droll{\alpha}{\tau}{d}
      \mid \Dunroll{d}
      \\ & & &
      \mid \cast{d}{\tau}{\tau}
      \mid \failedcast{d}{\tau}{\tau}
      \mid \dhole{\sigma}{u}
      \mid \dhole[d]{\sigma}{u}
      \\
    \IHTagArg & D & \Coloneqq &
      d
      \mid \cast{D}{\tau}{\tau}
      \mid \failedcast{D}{\tau}{\tau}
      \mid \hole{}
      \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsection{Context Extension}

We write $\Gamma, \asc{X}{T}$ to denote the extension of typing context $\Gamma$ with optional variable $X$ of optional type $T$.
\[
  \Gamma, \asc{X}{T} = \begin{cases}
    \Gamma, \asc{x}{\tau} & X = x \wedge T = \tau \\
    \Gamma, \asc{x}{\hole{}} & X = x \wedge T = \None \\
    \Gamma & X = \None \\
  \end{cases}
\]
%
We write $\Theta, \pi$ to denote the extension of type variable context $\Theta$ with optional type variable name $\pi$.
\[
  \Theta, \pi = \begin{cases}
    \Theta, \alpha & \pi = \alpha \\
    \Theta & \pi = \hole{} \\
  \end{cases}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Static Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  [tau/pi]tau

\Judgment{
  \subst{\tau}{\pi}{\tau'} = \tau''
}{
  $\tau''$ is obtained by substituting $\tau$ for $\pi$ in $\tau'$
}

\[
  \arraycolsep=0pt
  \begin{array}{l@{\quad=\quad}l@{\quad}l}
    \subst{\tau}{\hole{}}{\tau'} & \tau'
    \\
    \subst{\tau}{\alpha}{ (\Tarrow{\tau_1}{\tau_2}) }
      & \Tarrow{ \subst{\tau}{\alpha}{\tau_1} }{ \subst{\tau}{\alpha}{\tau_1} } \\
    \subst{\tau}{\alpha}{ \alpha } & \tau \\
    \subst{\tau}{\alpha}{ \alpha_1 } & \tau' & \text{ when } \alpha \neq \alpha_1 \\
    \subst{\tau}{\alpha}{ \Trec{\alpha_1}{\tau_2} }
      & \Trec{\alpha_1}{ \subst{\tau}{\alpha}{\tau_2} }
      & \text{ when } \alpha \neq \alpha_1 \text{ and } \alpha_1 \notin \FV{\tau} \\
    \subst{\tau}{\alpha}{ \Trec{\hole{}}{\tau_2} } & \Trec{\hole{}}{ \subst{\tau}{\alpha}{\tau_2} } \\
    \subst{\tau}{\alpha}{ \Tsum{C_i(T_i)}_{C_i \in \TagSet} }
      & \Tsum{C_i( \subst{\tau}{\alpha}{T_i} )}_{C_i \in \TagSet} \\
    \subst{\tau}{\alpha}{ \hole{} } & \hole{} \\
    \subst{\alpha'}{\alpha}{ \hole[\alpha]{u} } & \hole[\alpha']{u} \\
    \subst{\alpha'}{\alpha}{ \hole[\alpha_1]{u} } & \hole[\alpha_1]{u} & \text{ when } \alpha \neq \alpha_1 \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  [tau/pi]T

\Judgment{
  \subst{\tau}{\pi}{T} = \tau'
}{
  $\tau'$ is obtained by substituting $\tau$ for $\pi$ in $T$
}

\[
  \subst{\tau}{\pi}{T} = \begin{cases}
    \subst{\tau}{\pi}{\tau'} & \text{when } T = \tau' \\
    \None & \text{when } T = \None \\
  \end{cases}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% join(tau1, tau2) = tau

\Judgment{
  \join{\tau_1}{\tau_2} = \tau
}{
  $\tau_1$ and $\tau_2$ join consistently, forming type $\tau$
}

\[
  \arraycolsep=0pt
  \begin{array}{l@{\quad=\quad}l@{\quad}l}
    \join{ \tau }{ \tau } & \tau \\
    \join{ \hole{} }{ \tau } & \tau \\
    \join{ \tau }{ \hole{} } & \tau \\
    \join{
      \Tarrow{\tau_1}{\tau_2}
    }{
      \Tarrow{\tau_1}{\tau_2}
    }
    & \Tarrow{ \join{\tau_1}{\tau_2} }{ \join{\tau_1}{\tau_2} }
    \\
    \join{
      \Trec{\pi_1}{T_1}
    }{
      \Trec{\pi_2}{T_2}
    }
    & \Trec{\join{\pi_1}{\pi_2}}{\join{T_1}{ \subst{\pi_1}{\pi_2}{T_2} }}
    \\
    \join{
      \Tsum{C_i(T_i)}_{C_i \in \TagSet}
    }{
      \Tsum{C_i(T_i')}_{C_i \in \TagSet}
    }
    & \Tsum{C_i(\join{T_i}{T_i'})}_{C_i \in \TagSet}
    \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% join(T1, T2) = T

\Judgment{
  \join{T_1}{T_2} = T
}{
  $T_1$ and $T_2$ join consistently, forming optional type $T$
}

\[
  \join{T_1}{T_2} = \begin{cases}
    \join{\tau_1}{\tau_2} & \text{when } T_1 = \tau_1 \wedge T_2 = \tau_2 \\
    \None & \text{when } T_1 = T_2 = \None \\
  \end{cases}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% join(pi1, pi2) = pi

% TODO: (eric) how to handle alpha-equivalence? (i.e. alpha1 != alpha2)

\Judgment{
  \join{\pi_1}{\pi_2} = \pi
}{
  $\pi_1$ and $\pi_2$ join consistently, forming type pattern $\pi$
}

\[
  \arraycolsep=0pt
  \begin{array}{l@{\quad=\quad}l@{\quad}l}
    \join{ \alpha }{ \alpha } & \alpha \\
    \join{ \hole{} }{ \alpha } & \alpha \\
    \join{ \alpha }{ \hole{} } & \alpha \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Theta |- tau valid

\Judgment{
  \valid{\Theta}{\tau}
}{
  $\tau$ is a valid type
}

\begin{mathpar}
  \inferrule[TVArr]{
    \valid{\Theta}{\tau_1} \\
    \valid{\Theta}{\tau_2}
  }{
    \valid{\Theta}{ \Tarrow{\tau_1}{\tau_2} }
  }

  \inferrule[TVVar]{
    \alpha \in \Theta
  }{
    \valid{\Theta}{ \alpha }
  }

  \inferrule[TVRec]{
    \valid{\Theta,\pi}{\tau}
  }{
    \valid{\Theta}{ \Trec{\pi}{\tau} }
  }

  \inferrule[TVSum]{
    \Set{ \valid{\Theta}{T_i} }_{C_i \in \TagSet}
  }{
    \valid{\Theta}{ \Tsum{ C_i(T_i) }_{C_i \in \TagSet} }
  }

  \inferrule[TVHole]{
    %
  }{
    \valid{\Theta}{\hole{}}
  }

  \inferrule[TVNEHole]{
    \alpha \notin \Theta
  }{
    \valid{\Theta}{ \hole[\alpha]{u} }
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Theta |- T valid

\Judgment{
  \valid{\Theta}{T}
}{
  $T$ is a valid optional type
}

\begin{mathpar}
  \inferrule[TVSome]{
    T = \tau \\
    \valid{\Theta}{\tau}
  }{
    \valid{\Theta}{T}
  }

  \inferrule[TVNone]{
    %
  }{
    \valid{\Theta}{\None}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% tau ~ tau'

\Judgment{
  \consistent{\tau}{\tau'}
}{
  $\tau$ and $\tau'$ are consistent
}

\begin{mathpar}
  \inferrule[TCHole1]{
    %
  }{
    \consistent{\hole{}}{\tau}
  }

  \inferrule[TCHole2]{
    %
  }{
    \consistent{\tau}{\hole{}}
  }

  \inferrule[TCRefl]{
    %
  }{
    \consistent{\tau}{\tau}
  }

  \inferrule[TCArr]{
    \consistent{\tau_1}{\tau_1'} \\
    \consistent{\tau_2}{\tau_2'}
  }{
    \consistent{\Tarrow{\tau_1}{\tau_2}}{\Tarrow{\tau_1'}{\tau_2'}}
  }

  \inferrule[TCRec]{
    \pi_1 = \pi_1' \\
    \consistent{\tau_2}{\tau_2'}
  }{
    \consistent{
      \Trec{\pi_1}{\tau_2}
    }{
      \Trec{\pi_1'}{\tau_2'}
     }
  }

  \inferrule[TCRecHole1]{
    \alpha \notin \FV{\tau} \\
    \consistent{\tau}{\tau'}
  }{
    \consistent{
      \Trec{\hole{}}{\tau}
    }{
      \Trec{\alpha}{\tau'}
     }
  }

  \inferrule[TCRecHole2]{
    \alpha \notin \FV{\tau} \\
    \consistent{\tau}{\tau'}
  }{
    \consistent{
        \Trec{\alpha}{\tau}
      }{
        \Trec{\hole{}}{\tau'}
     }
  }

  \inferrule[TCSum]{
    \consistent{\tau_i}{\tau_i'}
  }{
    \consistent{
      \Tsum{C_i(\tau_i)}_{C_i \in \TagSet}
    }{
      \Tsum{C_i(\tau_i')}_{C_i \in \TagSet}
    }
  }
\end{mathpar}

% For \textsc{TCRecVar}, we choose to substitute $\alpha_1$ for $\alpha_2$ arbitrarily.
% Due to this asymmetry, recursive types are only consistent up to alpha renaming.

\subsection{Bidirectional Typing}

We call $\subst{\Trec{\pi}{\tau}}{\pi}{\tau}$ the \emph{unrolling} of recursive type $\Trec{\pi}{\tau}$.

\begin{Theorem}[Synthetic Type Validity]
    If $\syn{\Gamma}{e}{\tau}$ then $\valid{\emptyset}{\tau}$.
\end{Theorem}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  tau |> tau_1 -> tau_2

\Judgment{
  \MatchedArrowTyp{\tau}{\tau_1}{\tau_2}
}{
  $\tau$ has matched arrow type $\Tarrow{\tau_1}{\tau_2}$
}

\begin{mathpar}
  \inferrule[MAHole]{
    %
  }{
    \MatchedArrowTyp{\hole{}}{\hole{}}{\hole{}}
  }

  \inferrule[MAArr]{
    %
  }{
    \MatchedArrowTyp{ \Tarrow{\tau_1}{\tau_2} }{\tau_1}{\tau_2}
  }
\end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \MatchedRecTyp{\tau}{\pi}{\tau'}
}{
  $\tau$ has matched recursive type $\Trec{\pi}{\tau'}$
}

\begin{mathpar}
  \inferrule[MRRec]{
    %
  }{
    \MatchedRecTyp{ \Trec{\pi}{\tau} }{\pi}{\tau}
  }

  \inferrule[MRHole]{
    %
  }{
    \MatchedRecTyp{ \hole{} }{\hole{}}{\hole{}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e => tau

\Judgment{
  \syn{\Gamma}{e}{\tau}
}{
  $e$ synthesizes type $\tau$
}

\begin{mathpar}
  \inferrule[SVar]{
    \asc{x}{\tau} \in \Gamma
  }{
    \syn{\Gamma}{x}{\tau}
  }

  \inferrule[SVarFree]{
    \asc{x}{\tau} \notin \Gamma
  }{
    \syn{\Gamma}{ \hole[x]{u} }{\hole{}}
  }

  \inferrule[SLam]{
    \valid{\emptyset}{\tau} \\
    \syn{\Gamma,\asc{x}{\tau}}{e}{\tau'}
  }{
    \syn{\Gamma}{ \Efun{x}{\tau}{e} }{\Tarrow{\tau}{\tau'}}
  }

  \inferrule[SApp]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \MatchedArrowTyp{\tau_1}{\tau_2}{\tau} \\
    \ana{\Gamma}{e_2}{\tau_2}
  }{
    \syn{\Gamma}{ \Eapp{e_1}{e_2} }{\tau}
  }

  \inferrule[SAppNotArr]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \notconsistent{\tau_1}{\Tarrow{\hole{}}{\hole{}}} \\
    \ana{\Gamma}{e_2}{\hole{}}
  }{
    \syn{\Gamma}{ \hole[ \Eapp{e_1}{e_2} ]{u} }{\hole{}}
  }

  \inferrule[SAsc]{
    \valid{\emptyset}{\tau} \\
    \ana{\Gamma}{e}{\tau}
  }{
    \syn{\Gamma}{ \asc{e}{\tau} }{\tau}
  }

  \inferrule[SRollError]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \syn{\Gamma}{ \hole[ \Eroll{e} ]{u} }{ \Trec{\hole{}}{\hole{}} }
  }

  \inferrule[SUnroll]{
    \syn{\Gamma}{e}{ \tau } \\
    \MatchedRecTyp{\tau}{\pi}{\tau'}
  }{
    \syn{\Gamma}{ \Eunroll{e} }{\subst{ \Trec{\pi}{\tau'} }{\pi}{\tau'}}
  }

  \inferrule[SUnrollNotRec]{
    \syn{\Gamma}{e}{\tau} \\
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}}
  }{
    \syn{\Gamma}{ \hole[ \Eunroll{e} ]{u} }{\hole{}}
  }

  \inferrule[SInjError]{
    \valid{\Gamma}{E}
  }{
    \syn{\Gamma}{ \hole[ \Einj{C}{E} ]{u} }{\hole{}}
  }

  % \inferrule[SCaseError]{
  %   \ana{\Gamma}{e}{\hole{}} \\
  %   \Set{ \ana{\Gamma,\asc{X_i}{\hole{}}}{e_i}{\hole{}} }_{C_i \in \TagSet}
  % }{
  %   \syn{\Gamma}{ \hole[ \Ecase{e}{ C_i(X_i){=}e_i} ]{u} }{\hole{}}
  % }

  \inferrule[SEHole]{
    %
  }{
    \syn{\Gamma}{ \hole{u} }{\hole{}}
  }

  \inferrule[SNEHole]{
    \syn{\Gamma}{e}{\tau}
  }{
    \syn{\Gamma}{ \hole[e]{u} }{\hole{}}
  }
\end{mathpar}

% \textsc{SInj} = Injection in Synthetic Position or Analyzed Against Non-Sum

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- E valid

\Judgment{
  \valid{\Gamma}{E}
}{
  $E$ is a valid optional expression
}

\begin{mathpar}
  \inferrule[EVSome]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \valid{\Gamma}{e}
  }

  \inferrule[EVNone]{
    %
  }{
    \valid{\Gamma}{\None}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e <= tau

\Judgment{
  \ana{\Gamma}{e}{\tau}
}{
  $e$ analyzes against type $\tau$
}

\begin{mathpar}
  \inferrule[ARoll]{
    \MatchedRecTyp{\tau}{\pi}{\tau'} \\
    \ana{\Gamma}{e}{ \subst{\tau}{\pi}{\tau'} }
  }{
    \ana{\Gamma}{ \Eroll{e} }{\tau}
  }

  \inferrule[ARollNotRec]{
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}}
  }{
    \ana{\Gamma}{ \hole[\Eroll{e}]{u} }{\tau}
  }

  \inferrule[AInjHole]{
    \valid{\Gamma}{E}
  }{
    \ana{\Gamma}{ \Einj{C}{E} }{\hole{}}
  }

  \inferrule[AInj]{
    C_j \in \TagSet \\
    \ana{\Gamma}{E}{T_j}
  }{
    \ana{\Gamma}{ \Einj{C_j}{E} }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjUnexpectedBody]{
    C_j \in \TagSet \\
    T_j = \None \\
    \ana{\Gamma}{e}{\hole{}}
  }{
    \ana{\Gamma}{ \hole[\Einj{C_j}{e}]{u} }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjExpectedBody]{
    C_j \in \TagSet \\
    T_j = \tau
  }{
    \ana{\Gamma}{ \hole[\Einj{C_j}{\None}]{u} }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjBadTag]{
    C \notin \TagSet \\
    \valid{\Gamma}{E}
  }{
    \ana{\Gamma}{
      \hole[\Einj{C}{E}]{u}
    }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[ASubsume]{
    \syn{\Gamma}{e}{\tau'} \\
    \consistent{\tau'}{\tau}
  }{
    \ana{\Gamma}{e}{\tau}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- E <= T

\Judgment{
  \ana{\Gamma}{E}{T}
}{
  $E$ analyzes against optional type $T$
}

\begin{mathpar}
  \inferrule[ASome]{
    E = e \\
    T = \tau \\
    \ana{\Gamma}{e}{\tau}
  }{
    \ana{\Gamma}{E}{T}
  }

  \inferrule[ANone]{
    %
  }{
    \ana{\Gamma}{\None}{\None}
  }
\end{mathpar}

\subsection{Typed Elaboration}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e => tau ~> d -| Delta

\Judgment{
  \synelab{\Gamma}{e}{\tau}{d}{\Delta}
}{
  $e$ synthesizes type $\tau$ and elaborates to $d$
}

\begin{mathpar}
  \inferrule[ESUnroll]{
    \synelab{\Gamma}{e}{\tau'}{d}{\Delta} \\
    \MatchedRecTyp{\tau'}{\pi}{\tau}
  }{
    \synelab{\Gamma}{
      \Eunroll{e}
    }{ \subst{\Trec{\pi}{\tau}}{\pi}{\tau} }{
      \Dunroll{d}
    }{\Delta}
  }

  \inferrule[ESInj]{
    \anaelab{\Gamma}{E}{ \hole{} }{D}{T}{\Delta}
  }{
    \synelab{\Gamma}{
      \hole[ \Einj{C}{E} ]{u}
    }{ \hole{} }{
      \hole[
        \Dinj{ \hole{} }{C}{ \cast{D}{T}{ \hole{} } }
      ]{u}_{ \id{\Gamma} }
    }{\Delta, u :: \hole{}[\Gamma]}
  }
\end{mathpar}

% TODO: define D<T => T>

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e <= tau_1 ~> d : tau_2 -| Delta

\Judgment{
  \anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}
}{
  $e$ analyzes against type $\tau_1$ and elaborates to $d$ of consistent type $\tau_2$
}

\begin{mathpar}
  \inferrule[EARoll]{
    \anaelab{\Gamma}{
      e
    }{\subst{ \Trec{\pi}{\tau} }{\pi}{\tau}}{
      d
    }{\tau'}{\Delta}
  }{
    \anaelab{\Gamma}{
      \Eroll{e}
    }{ \Trec{\pi}{\tau} }{
      \Droll{\pi}{\tau}{
        \cast{d}{\tau'}{ \subst{ \Trec{\pi}{\tau} }{\pi}{\tau} }
      }
    }{\Trec{\pi}{\tau}}{
      \Delta
    }
  }

  \inferrule[EAInj]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    \anaelab{\Gamma}{E}{T_j}{D}{T_j'}{\Delta}
  }{
    \anaelab{\Gamma}{
      \Einj{C_j}{E}
    }{\tau}{
      \Dinj{\tau}{C_j}{ \cast{D}{T_j'}{T_j} }
    }{\tau}{\Delta}
  }

  \inferrule[EAInjHole]{
    \anaelab{\Gamma}{E}{ \hole{} }{D}{T}{\Delta} \\
    \tau = \Tsum{C(T)}
  }{
    \anaelab{\Gamma}{
      \Einj{C}{E}
    }{ \hole{} }{
      \Dinj{\tau}{C}{D}
    }{\tau}{\Delta}
  }

  \inferrule[EAInjUnexpectedBody]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    T_j = \None \\
    \anaelab{\Gamma}{e}{ \hole{} }{d}{\tau_j}{\Delta} \\
    \tau' = \tau \uplus \Tsum{C_j(\tau_j)}
  }{
    \anaelab{\Gamma}{
      \hole[ \Einj{C_j}{e} ]{u}
    }{\tau}{
      \hole[ \Dinj{\tau'}{C_j}{d} ]{u}_{\id{\Gamma}}
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjExpectedBody]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    C_j \in \TagSet \\
    T_j = \tau_j \\
    \tau' = \tau \uplus \Tsum{C_j(\None)}
  }{
    \anaelab{\Gamma}{
      \hole[ \Einj{C_j}{\None} ]{u}
    }{\tau}{
      \hole[ \Dinj{\tau'}{C_j}{\None} ]{u}_{\id{\Gamma}}
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }

  \inferrule[EAInjBadTag]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    C \notin \TagSet \\
    \anaelab{\Gamma}{E}{ \hole{} }{D}{T}{\Delta} \\
    \tau' = \tau \uplus \Tsum{C(T)}
  }{
    \anaelab{\Gamma}{
      \hole[ \Einj{C}{E} ]{u}
    }{\tau}{
      \hole[ \Dinj{\tau'}{C}{D} ]{u}_{\id{\Gamma}}
    }{\tau}{\Delta, u :: \tau[\Gamma]}
  }
\end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- E <= T_1 ~> D : T_2 -| Delta

\Judgment{
  \anaelab{\Gamma}{E}{T_1}{D}{T_2}{\Delta}
}{
  $E$ analyzes against optional type $T_1$ and elaborates to $D$ of consistent optional type $T_2$
}

\begin{mathpar}
  \inferrule[EASome]{
    \anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}   
  }{
    \anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}
  }

  \inferrule[EANone]{
    % 
  }{
    \anaelab{\Gamma}{\None}{\None}{\None}{\None}{\emptyset}
  }
\end{mathpar}

\subsection{Type Assignment}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Delta; Gamma |- d : tau

\Judgment{
  \assign{\Delta}{\Gamma}{d}{\tau}
}{
  $d$ is assigned type $\tau$
}

\begin{mathpar}
  \inferrule[TAVar]{
    \asc{x}{\tau} \in \Gamma
  }{
    \assign{\Delta}{\Gamma}{ x }{ \tau }
  }

  \inferrule[TALam]{
    \assign{\Delta}{\Gamma, \asc{x}{\tau_1}}{ d }{ \tau_2 }
  }{
    \assign{\Delta}{\Gamma}{ \Dfun{x}{\tau_1}{d} }{ \tau_1 \to \tau_2 }
  }

  \inferrule[TAApp]{
    \assign{\Delta}{\Gamma}{ d_1 }{ \Tarrow{\tau_2}{\tau} } \\
    \assign{\Delta}{\Gamma}{ d_2 }{ \tau_2 }
  }{
    \assign{\Delta}{\Gamma}{ \Dapp{d_1}{d_2} }{ \tau }
  }

  \inferrule[TAEHole]{
    u :: \tau[\Gamma'] \in \Delta \\
    \assign{\Delta}{\Gamma}{ \sigma }{ \Gamma' }
  }{
    \assign{\Delta}{\Gamma}{ \dhole{\sigma}{u} }{ \tau }
  }

  \inferrule[TANEHole]{
    \assign{\Delta}{\Gamma}{ d }{ \tau' } \\
    u :: \tau[\Gamma'] \in \Delta \\
    \assign{\Delta}{\Gamma}{ \sigma }{ \Gamma' }
  }{
    \assign{\Delta}{\Gamma}{ \dhole{\sigma}{u} }{ \tau }
  }

  \inferrule[TACast]{
    \assign{\Delta}{\Gamma}{ d }{ \tau_1 } \\
    \consistent{\tau_1}{\tau_2}
  }{
    \assign{\Delta}{\Gamma}{ \cast{d}{\tau_1}{\tau_2} }{ \tau_2 }
  }

  \inferrule[TAFailedCast]{
    \assign{\Delta}{\Gamma}{ d }{ \tau_1 } \\
    \ground{\tau_1} \\
    \ground{\tau_2} \\
    \tau_1 \neq \tau_2
  }{
    \assign{\Delta}{\Gamma}{ \failedcast{d}{\tau_1}{\tau_2} }{ \tau_2 }
  }

%   \inferrule[TRoll]{
%     \assign{\Delta}{\Gamma}{d}{ \subst{\Trec{\alpha}{\tau}}{\alpha}{\tau} }
%   }{
%     \assign{\Delta}{\Gamma}{ \Droll{\Trec{\alpha}{\tau}}{d} }{ \Trec{\alpha}{\tau} }
%   }

%   \inferrule[TUnroll]{
%     \assign{\Delta}{\Gamma}{d}{ \Trec{\alpha}{\tau} }
%   }{
%     \assign{\Delta}{\Gamma}{\unroll{d}}{ \subst{\Trec{\alpha}{\tau}}{\alpha}{\tau} }
%   }

%   \inferrule[TInj]{
%     \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
%     C_j \in \TagSet \\
%     \assign{\Delta}{\Gamma}{D}{T_j}
%   }{
%     \assign{\Delta}{\Gamma}{\Dinj{\tau}{C_j}{D}}{\tau}
%   }

%   \inferrule[TCase]{
%     \assign{\Delta}{\Gamma}{d}{\Tsum{C_i(T_i)}_{C_i \in \TagSet}} \\
%     \assign{\Delta}{\Gamma, X_i : T_i}{d_i}{\tau} \\
%     i = 1, \ldots, N
%   }{
%     \assign{\Delta}{\Gamma}{
%       \case{d}{C_i(X_i){=}d_i}_{C_i \in \TagSet}
%     }{\tau}
%   }

%   \inferrule[TCaseU]{
%     \assign{\Delta}{\Gamma}{d}{\hole} \\
%     \assign{\Delta}{\Gamma, X_i : \hole}{d_i}{\tau} \\
%     i = 1, \ldots, N
%   }{
%     \assign{\Delta}a{\Gamma}{\case{d}{C_i(X_i){=}{d_i}}_{C_i \in \TagSet}}{\tau}
%   }
\end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- D : T

% \noindent
% $\boxed{\assignD{\Delta}{\Gamma}{D}{T}}$
% \quad $D$ is assigned optional type $T$

% \begin{mathpar}
%   \inferrule{
%     \assign{\Delta}{\Gamma}{d}{\tau}
%   }{
%     \assignD{\Delta}{\Gamma}{d}{\tau}
%   }

%   \inferrule{
%     % 
%   }{
%     \assign{\Delta}{\Gamma}{\None}{\None}
%   }
% \end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dynamic Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% tau ground

\Judgment{
  \ground{\tau}
}{
  $\tau$ is a ground type
}

\begin{mathpar}
  \inferrule[GArr]{
  }{
    \ground{ \Tarrow{\hole{}}{\hole{}} }
  }

  \inferrule[GRec]{
  }{
    \ground{ \Trec{\hole{}}{\hole{}} }
  }

  \inferrule[GSum]{
    \Set{T_i = \hole{} \vee T_i = \None}_{C_i \in \TagSet}
  }{
    \ground{ \Tsum{C_i(T_i)}_{C_i \in \TagSet} }
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \MatchedGroundTyp{\tau}{\tau'}
}{
  $\tau$ has matched ground type $\tau'$
}

\begin{mathpar}
  \inferrule[MGSum]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    \tau' = \Tsum{C_i(T_i')}_{C_i \in \TagSet} \\
    \tau \neq \tau' \\
    \Set{
      T_i =   \tau_i \implies T_i' = \hole \wedge
      T_i = \None \implies T_i' = \None
    }_i
  }{
    \MatchedGroundTyp{\tau}{\tau'}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \value{d}
}{
  $d$ is a value
}

\begin{mathpar}
  \inferrule[VRoll]{
    \val{d}
  }{
    \val{ \Droll{\pi}{\tau}{d} }
  }

  \inferrule[VUnroll]{
    \val{d}
  }{
    \val{\Dunroll{d}}
  }

  \inferrule[VInj]{
    \val{d}
  }{
    \val{ \Dinj{\tau}{\Tag}{d} }
  }

  \inferrule[VInjNull]{
  }{
    \val{ \Dinj{\tau}{\Tag}{\None} }
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \boxedval{d}
}{
  $d$ is a boxed value
}

\begin{mathpar}
  \inferrule[BVRoll]{
    \boxedval{d}
  }{
    \boxedval{\Droll{\pi}{\tau}{d}}
  }

  \inferrule[BVUnroll]{
    \boxedval{d}
  }{
    \boxedval{\Dunroll{d}}
  }

  \inferrule[BVInj]{
    \boxedval{d}
  }{
    \boxedval{\Dinj{\tau}{\Tag}{d}}
  }

  \inferrule[BVSumCast]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    \tau' = \Tsum{C_i(T_i')}_{C_i \in \TagSet} \\
    \tau \neq \tau' \\
    \boxedval{d}
  }{
    \boxedval{\cast{d}{\tau}{\tau'}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \indet{d}
}{
  $d$ is indeterminate
}

\begin{mathpar}
  \inferrule[IRoll]{
    \indet{d}
  }{
    \indet{\Droll{\Trec{\alpha}{\tau}}{d}}
  }

  \inferrule[IUnroll]{
    \indet{d}
  }{
    \indet{\Dunroll{d}}
  }

  \inferrule[IInj]{
    \indet{d}
  }{
    \indet{\Dinj{\tau}{\Tag}{d}}
  }

  \inferrule[IInjTag]{
    \final{d}
  }{
    \indet{\Dinj{\tau}{ \hole{} }{d}}
  }

  \inferrule[IInjNull]{
  }{
    \indet{\Dinj{\tau}{ \hole{} }{\None}}
  }

  \inferrule[ICastSum]{
    \tau = \Tsum{C_i(T_i)}_{C_i \in \TagSet} \\
    \tau' = \Tsum{C_i(T_i')}_{C_i \in \TagSet} \\
    \tau \neq \tau' \\
    \indet{d}
  }{
    \indet{\cast{d}{\tau}{\tau'}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\[
  \arraycolsep=0pt  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \EvalCtx & \E & {}\Coloneqq{} &
      \ldots
      \mid \Droll{\pi}{\tau}{\E}
      \mid \Dinj{\tau}{C}{\E}
    \\
  \end{array}
\]

\Judgment{
  \eval{d}{\E}{d'}
}{
  $d$ is obtained by placing $d'$ at the mark in $\E$
}

\begin{mathpar}
  \inferrule[FHRoll]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \Droll{\pi}{\tau}{d}
    }{\Droll{\pi}{\tau}{\E}
    }{d'}
  }

  \inferrule[FHUnroll]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \Dunroll{d}
    }{\Dunroll{\E}
    }{d'}
  }

  \inferrule[FHInj]{
    \eval{d}{\E}{d'}
  }{
    \eval{
      \Dinj{\tau}{C}{d}
    }{\Dinj{\tau}{C}{\E}
    }{d'}
  }
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}