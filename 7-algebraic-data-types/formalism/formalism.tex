\documentclass{article}

\usepackage{fullpage}
\usepackage{amsmath, stmaryrd, amssymb, mathtools, mathpartir}

% fix spacing between math operators and large paired delimiters
\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}

% Theorems and Proofs

\usepackage{amsthm}
\newtheorem{Theorem}{Theorem}
\newtheorem{Lemma}[Theorem]{Lemma}

\usepackage{pfsteps}
\renewcommand\byCasesEveryCase{}
\setlength{\proofrightwidth}{0.4\linewidth}

% Sets

\newcommand{\Set}[1]{\left\{#1\right\}}

% Sorts

\newcommand\Sort[1]{\mathsf{#1}}

\newcommand\IHExp{\Sort{IHExp}}
\newcommand\IHTagArg{\Sort{IHTagArg}}
\newcommand\HExp{\Sort{HExp}}
\newcommand\HExpPat{\Sort{HExpPat}}
\newcommand\HTag{\Sort{HTag}}
\newcommand\HTagArg{\Sort{HTagArg}}
\newcommand\HTagTyp{\Sort{HTagTyp}}
\newcommand\HTagVar{\Sort{HTagVar}}
\newcommand\HTyp{\Sort{HTyp}}
\newcommand\HTypPat{\Sort{HTypPat}}

% Holes

\newcommand\hole[2][]{\llparenthesis#1\rrparenthesis^{#2}}
\newcommand\Dhole[3][]{\llparenthesis#1\rrparenthesis_{#2}^{#3}}

% Types

\newcommand\Tarrow[2]{#1 \rightarrow #2}
\newcommand\Trec[2]{\mu{#1}.{#2}}
\newcommand\Tsum[1]{+\mathopen{}\left\{#1\right\}}

% Tags

\newcommand\Tag{\mathbf{C}}
\newcommand\TagHole[2][]{\llparenthesis#1\rrparenthesis^{#2}}
\newcommand\TagSet{\mathcal{C}}

% Optional Tag Arguments

\newcommand\Missing{\varnothing}

% Token Literals

\newcommand\literal[1]{\mathtt{#1}}

% Type Ascription

\newcommand\asc[2]{{#1}:{#2}}

% External Expressions

\newcommand\Efun[3]{\lambda{#1}{:}{#2}.{#3}}
\newcommand\Eapp[2]{{#1}\left({#2}\right)}
\newcommand\Einj[2]{\literal{inj}_{#1}\left({#2}\right)}
\newcommand\Ecase[2]{\literal{case} \left({#1}\right) \left\{{#2}\right\}}
\newcommand\Eroll[1]{\literal{roll}\left(#1\right)}
\newcommand\Eunroll[1]{\literal{unroll}\left(#1\right)}

% Internal Expressions

\newcommand\Dfun[3]{\lambda{#1}{:}{#2}.{#3}}
\newcommand\Dapp[2]{{#1}\left({#2}\right)}
\newcommand\Dinj[3]{\literal{inj}_{#1}^{#2}\left({#3}\right)}
\newcommand\Dcase[2]{\literal{case} \left({#1}\right) \left\{{#2}\right\}}
\newcommand\Droll[3]{\literal{roll}^{\Trec{#1}{#2}}\left({#3}\right)}
\newcommand\Dunroll[1]{\literal{unroll}\left(#1\right)}
\newcommand\cast[3]{{#1}\langle{#2}\Rightarrow{#3}\rangle}
\newcommand\casts[4]{{#1}\langle{#2}\Rightarrow{#3}\Rightarrow{#4}\rangle}
\newcommand\castfail[3]{{#1}\langle{#2}\Rightarrow{\llparenthesis\rrparenthesis}\nRightarrow{#3}\rangle}

% Judgments

\newcommand\Judgment[2]{\noindent{}$\boxed{#1}$\quad{#2}}
\newcommand\helper[1]{\mathsf{#1}}

\newcommand\syn[3]{{#1}\vdash{#2}\Rightarrow{#3}}
\newcommand\ana[3]{{#1}\vdash{#2}\Leftarrow{#3}}

% Helpers

\newcommand\consistent[2]{{#1}\sim{#2}}
\newcommand\notconsistent[2]{{#1}\nsim{#2}}
\newcommand\valid[2]{{#1}\vdash{#2}\,\helper{valid}}
% \newcommand\ValidExp[3]{{#1};{#2}\vdash{#3}\,\helper{valid}}
\newcommand\FV[1]{\mathsf{FV\left(#1\right)}}

% Matched Types

\newcommand\MatchedArrowTyp[3]{{#1}\blacktriangleright_\rightarrow{#2}\rightarrow{#3}}
\newcommand\MatchedRecTyp[3]{{#1}\blacktriangleright_\mu\Trec{#2}{#3}}

% Substitution

\newcommand\subst[3]{\left[{#1}/{#2}\right]{#3}}


% \newcommand{\valid}[2]{#1 \vdash #2~\mathsf{valid}}
% \newcommand{\assign}[4]{#1; #2 \vdash #3 : #4}
% \newcommand{\ana}[3]{#1 \vdash #2 \Leftarrow #3}
% \newcommand{\synelab}[5]{#1 \vdash #2 \Rightarrow #3 \leadsto #4 \dashv #5}
% \newcommand{\anaelab}[6]{#1 \vdash #2 \Leftarrow #3 \leadsto #4 : #5 \dashv #6}
% \newcommand{\anaE}[3]{#1 \vdash_E #2 \Leftarrow #3}
% \newcommand{\synelabE}[5]{#1 \vdash_E #2 \Rightarrow #3 \leadsto #4 \dashv #5}
% \newcommand{\anaelabE}[6]{#1 \vdash_E #2 \Leftarrow #3 \leadsto #4 : #5 \dashv #6}
% \newcommand{\assignD}[4]{#1; #2 \vdash_D #3 : #4}
% \newcommand{\consistent}[2]{#1 \sim #2}
% \newcommand{\matchedRec}[2]{#1 \blacktriangleright_\mu #2}
% \newcommand{\join}[2]{\mathsf{join}\left(#1,#2\right)}
% \newcommand{\ground}[1]{#1~\mathsf{ground}}
% \newcommand{\matchedGround}[2]{#1 \blacktriangleright_{\mathsf{ground}} #2}
% \newcommand{\val}[1]{#1~\mathsf{val}}
% \newcommand{\boxedval}[1]{#1~\mathsf{boxedval}}
% \newcommand{\indet}[1]{#1~\mathsf{indet}}
% \newcommand{\final}[1]{#1~\mathsf{final}}
% \newcommand{\eval}[3]{#1 = #2\mathopen{}\left\{#3\right\}\mathclose{}}

% Evaluation Contexts
% \newcommand{\E}{\mathcal{E}}

% Operations
% \newcommand{\subst}[3]{[#1 / #2]#3}0
% \newcommand{\defeq}{\stackrel{\text{def}}{=}}
% \newcommand{\cast}[3]{#1\langle#2\,{\Rightarrow}\,#3\rangle}

% Helpers
% \DeclareMathOperator{\id}{\text{id}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Algebraic Data Types for Hazel}
\author{Eric Griffis \\ egriffis@umich.edu}
\date{}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Syntax}

\[
  \arraycolsep=0pt
  \begin{array}{l@{~~}c@{~~}c@{~~}l}
    \HTyp & \tau & \Coloneqq &
      \Tarrow{\tau}{\tau}
      \mid \alpha
      \mid \Trec{\pi}{\tau}
      \mid \Tsum{C_i(T_i)}_{C_i \in \TagSet}
      \mid \hole{}
      \mid \hole[\alpha]{u}
      \\
    \HTypPat & \pi & \Coloneqq & \alpha \mid \hole{} \\
    \HExp & e & \Coloneqq &
      x
      \mid \Efun{x}{\tau}{e}
      \mid \Eapp{e}{e}
      \mid \asc{e}{\tau}
      \mid \Einj{C}{E}
      % \mid \Ecase{e}{C_i(X_i){=}e_i}_{C_i \in \TagSet}
      \mid \Eroll{e}
      \mid \Eunroll{e}
      \\ & & &
      \mid \hole{u}
      \mid \hole[e]{u}
      \\
    \HTagTyp & T & \Coloneqq & \tau \mid \Missing \\
    \HTagArg & E & \Coloneqq & e \mid \Missing \\
    % \HTagVar & X & \Coloneqq & x \mid \Missing \\
    \IHExp & d & \Coloneqq &
      x
      \mid \Dfun{x}{\tau}{d}
      \mid \Dapp{d}{d}
      \mid \Dinj{C}{\tau}{D}
      % \mid \Dcase{d}{C_i(X_i)}_{C_u \in \TagSet}
      \mid \Droll{\alpha}{\tau}{d}
      \mid \Dunroll{d}
      \\ & & &
      \mid \cast{d}{\tau}{\tau}
      \mid \castfail{d}{\tau}{\tau}
      \mid \Dhole{\sigma}{u}
      \mid \Dhole[d]{\sigma}{u}
      \\
    \IHTagArg & D & \Coloneqq &
      d
      \mid \cast{D}{\tau}{\tau}
      \mid \castfail{D}{\tau}{\tau}
      \mid \hole{}
      \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\subsection{Context Extension}

We write $\Gamma, \asc{X}{T}$ to denote the extension of typing context $\Gamma$ with optional variable $X$ of optional type $T$.
\[
  \Gamma, \asc{X}{T} = \begin{cases}
    \Gamma, \asc{x}{\tau} & X = x \wedge T = \tau \\
    \Gamma, \asc{x}{\hole{}} & X = x \wedge T = \Missing \\
    \Gamma & X = \Missing \\
  \end{cases}
\]

We write $\Theta, \pi$ to denote the extension of type variable context $\Theta$ with optional type variable name $\pi$.
\[
  \Theta, \pi = \begin{cases}
    \Theta, \alpha & \pi = \alpha \\
    \Theta & \pi = \hole{} \\
  \end{cases}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Static Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  [tau/pi]tau

\Judgment{
  \subst{\tau}{\pi}{\tau'} = \tau''
}{
  $\tau''$ is obtained by substituting $\tau$ for $\pi$ in $\tau'$
}

\[
  \arraycolsep=0pt
  \begin{array}{l@{\quad=\quad}l@{\quad}l}
    \subst{\tau}{\hole{}}{\tau'} & \tau'
    \\
    \subst{\tau}{\alpha}{ (\Tarrow{\tau_1}{\tau_2}) }
      & \Tarrow{ \subst{\tau}{\alpha}{\tau_1} }{ \subst{\tau}{\alpha}{\tau_1} } \\
    \subst{\tau}{\alpha}{ \alpha } & \tau \\
    \subst{\tau}{\alpha}{ \alpha_1 } & \tau' & \text{ when } \alpha \neq \alpha_1 \\
    \subst{\tau}{\alpha}{ \Trec{\alpha_1}{\tau_2} }
      & \Trec{\alpha_1}{ \subst{\tau}{\alpha}{\tau_2} }
      & \text{ when } \alpha \neq \alpha_1 \text{ and } \alpha_1 \notin \FV{\tau} \\
    \subst{\tau}{\alpha}{ \Trec{\hole{}}{\tau_2} } & \Trec{\hole{}}{ \subst{\tau}{\alpha}{\tau_2} } \\
    \subst{\tau}{\alpha}{ \Tsum{C_i(T_i)}_{C_i \in \TagSet} }
      & \Tsum{C_i( \subst{\tau}{\alpha}{T_i} )}_{C_i \in \TagSet} \\
    \subst{\tau}{\alpha}{ \hole{} } & \hole{} \\
    \subst{\alpha'}{\alpha}{ \hole[\alpha]{u} } & \hole[\alpha']{u} \\
    \subst{\alpha'}{\alpha}{ \hole[\alpha_1]{u} } & \hole[\alpha_1]{u} & \text{ when } \alpha \neq \alpha_1 \\
  \end{array}
\]

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  [tau/pi]T

\Judgment{
  \subst{\tau}{\pi}{T} = \tau'
}{
  $\tau'$ is obtained by substituting $\tau$ for $\pi$ in $T$
}

\[
  \subst{\tau}{\pi}{T} = \begin{cases}
    \subst{\tau}{\pi}{\tau'} & \text{when } T = \tau' \\
    \Missing & \text{when } T = \Missing \\
  \end{cases}
\]

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \noindent
% $\boxed{\join{\tau_1}{\tau_2} = \tau}$
% \quad $\tau_1$ and $\tau_2$ join consistently, forming type $\tau$

% \begin{mathpar}
%   \join{
%     \sumtype{C_i(\tau_i)}_{C_i \in \C}
%   }{
%     \sumtype{C_i(\tau_i')}_{C_i \in \C}
%   }
%   = \sumtype{C_i(\join{\tau_i}{\tau_i'})}_{C_i \in \C}

%   \join{
%     \rectype{\alpha_1}{\tau_1}
%   }{
%     \rectype{\alpha_2}{\tau_2}
%   }
%   = \rectype{\alpha_1}{\join{\tau_1}{ \subst{\alpha_1}{\alpha_2}{\tau_2} }}
% \end{mathpar}

% \vspace*{\baselineskip}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Theta |- tau valid

\Judgment{
  \valid{\Theta}{\tau}
}{
  $\tau$ is a valid type
}

\begin{mathpar}
  \inferrule[TVArr]{
    \valid{\Theta}{\tau_1} \\
    \valid{\Theta}{\tau_2}
  }{
    \valid{\Theta}{ \Tarrow{\tau_1}{\tau_2} }
  }

  \inferrule[TVVar]{
    \alpha \in \Theta
  }{
    \valid{\Theta}{ \alpha }
  }

  \inferrule[TVRec]{
    \valid{\Theta,\pi}{\tau}
  }{
    \valid{\Theta}{ \Trec{\pi}{\tau} }
  }

  \inferrule[TVSum]{
    \Set{ \valid{\Theta}{T_i} }_{C_i \in \TagSet}
  }{
    \valid{\Theta}{ \Tsum{ C_i(T_i) }_{C_i \in \TagSet} }
  }

  \inferrule[TVHole]{
    %
  }{
    \valid{\Theta}{\hole{}}
  }

  \inferrule[TVNEHole]{
    \alpha \notin \Theta
  }{
    \valid{\Theta}{ \hole[\alpha]{u} }
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Theta |- T valid

\Judgment{
  \valid{\Theta}{T}
}{
  $T$ is a valid optional type
}

\begin{mathpar}
  \inferrule[TVPresent]{
    T = \tau \\
    \valid{\Theta}{\tau}
  }{
    \valid{\Theta}{T}
  }

  \inferrule[TVNotPresent]{
    %
  }{
    \valid{\Theta}{\Missing}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% tau ~ tau'

\Judgment{
  \consistent{\tau}{\tau'}
}{
  $\tau$ and $\tau'$ are consistent
}

\begin{mathpar}
  \inferrule[TCHole1]{
    %
  }{
    \consistent{\hole{}}{\tau}
  }

  \inferrule[TCHole2]{
    %
  }{
    \consistent{\tau}{\hole{}}
  }

  \inferrule[TCRefl]{
    %
  }{
    \consistent{\tau}{\tau}
  }

  \inferrule[TCArr]{
    \consistent{\tau_1}{\tau_1'} \\
    \consistent{\tau_2}{\tau_2'}
  }{
    \consistent{\Tarrow{\tau_1}{\tau_2}}{\Tarrow{\tau_1'}{\tau_2'}}
  }

  \inferrule[TCRec]{
    \pi_1 = \pi_1' \\
    \consistent{\tau_2}{\tau_2'}
  }{
    \consistent{
      \Trec{\pi_1}{\tau_2}
    }{
      \Trec{\pi_1'}{\tau_2'}
     }
  }

  \inferrule[TCRecHole1]{
    \alpha \notin \FV{\tau} \\
    \consistent{\tau}{\tau'}
  }{
    \consistent{
      \Trec{\hole{}}{\tau}
    }{
      \Trec{\alpha}{\tau'}
     }
  }

  \inferrule[TCRecHole2]{
    \alpha \notin \FV{\tau} \\
    \consistent{\tau}{\tau'}
  }{
    \consistent{
        \Trec{\alpha}{\tau}
      }{
        \Trec{\hole{}}{\tau'}
     }
  }

  \inferrule[TCSum]{
    \consistent{\tau_i}{\tau_i'}
  }{
    \consistent{
      \Tsum{C_i(\tau_i)}_{C_i \in \TagSet}
    }{
      \Tsum{C_i(\tau_i')}_{C_i \in \TagSet}
    }
  }
\end{mathpar}

For \textsc{TCRecVar}, we choose to substitute $\alpha_1$ for $\alpha_2$ arbitrarily.
Due to this asymmetry, recursive types are only consistent up to alpha renaming.

\subsection{Bidirectional Typing}

We call $\subst{\Trec{\alpha}{\tau}}{\alpha}{\tau}$ the \emph{unrolling} of recursive type $\Trec{\alpha}{\tau}$.

\begin{Theorem}[Synthetic Type Validity]
    If $\syn{\Gamma}{e}{\tau}$ then $\valid{\emptyset}{\tau}$.
\end{Theorem}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  tau |> tau_1 -> tau_2

\Judgment{
  \MatchedArrowTyp{\tau}{\tau_1}{\tau_2}
}{
  $\tau$ has matched arrow type $\Tarrow{\tau_1}{\tau_2}$
}

\begin{mathpar}
  \inferrule[MAHole]{
    %
  }{
    \MatchedArrowTyp{\hole{}}{\hole{}}{\hole{}}
  }

  \inferrule[MAArr]{
    %
  }{
    \MatchedArrowTyp{ \Tarrow{\tau_1}{\tau_2} }{\tau_1}{\tau_2}
  }
\end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\Judgment{
  \MatchedRecTyp{\tau}{\pi}{\tau'}
}{
  $\tau$ has matched recursive type $\Trec{\pi}{\tau'}$
}

\begin{mathpar}
  \inferrule[MRRec]{
    %
  }{
    \MatchedRecTyp{ \Trec{\pi}{\tau} }{\pi}{\tau}
  }

  \inferrule[MRHole]{
    %
  }{
    \MatchedRecTyp{ \hole{} }{\hole{}}{\hole{}}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e => tau

\Judgment{
  \syn{\Gamma}{e}{\tau}
}{
  $e$ synthesizes type $\tau$
}

\begin{mathpar}
  \inferrule[SVar]{
    \asc{x}{\tau} \in \Gamma
  }{
    \syn{\Gamma}{x}{\tau}
  }

  \inferrule[SVarFree]{
    \asc{x}{\tau} \notin \Gamma
  }{
    \syn{\Gamma}{ \hole[x]{u} }{\hole{}}
  }

  \inferrule[SLam]{
    \valid{\emptyset}{\tau} \\
    \syn{\Gamma,\asc{x}{\tau}}{e}{\tau'}
  }{
    \syn{\Gamma}{ \Efun{x}{\tau}{e} }{\Tarrow{\tau}{\tau'}}
  }

  \inferrule[SApp]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \MatchedArrowTyp{\tau_1}{\tau_2}{\tau} \\
    \ana{\Gamma}{e_2}{\tau_2}
  }{
    \syn{\Gamma}{ \Eapp{e_1}{e_2} }{\tau}
  }

  \inferrule[SAppNotArr]{
    \syn{\Gamma}{e_1}{\tau_1} \\
    \notconsistent{\tau_1}{\Tarrow{\hole{}}{\hole{}}} \\
    \ana{\Gamma}{e_2}{\hole{}}
  }{
    \syn{\Gamma}{ \hole[ \Eapp{e_1}{e_2} ]{u} }{\hole{}}
  }

  \inferrule[SAsc]{
    \valid{\emptyset}{\tau} \\
    \ana{\Gamma}{e}{\tau}
  }{
    \syn{\Gamma}{ \asc{e}{\tau} }{\tau}
  }

  \inferrule[SRollError]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \syn{\Gamma}{ \hole[ \Eroll{e} ]{u} }{ \Trec{\hole{}}{\hole{}} }
  }

  \inferrule[SUnroll]{
    \syn{\Gamma}{e}{ \tau } \\
    \MatchedRecTyp{\tau}{\pi}{\tau'}
  }{
    \syn{\Gamma}{ \Eunroll{e} }{\subst{ \Trec{\pi}{\tau'} }{\pi}{\tau'}}
  }

  \inferrule[SUnrollNotRec]{
    \syn{\Gamma}{e}{\tau} \\
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}}
  }{
    \syn{\Gamma}{ \hole[ \Eunroll{e} ]{u} }{\hole{}}
  }

  \inferrule[SInjError]{
    \valid{\Gamma}{E}
  }{
    \syn{\Gamma}{ \hole[ \Einj{C}{E} ]{u} }{\hole{}}
  }

  % \inferrule[SCaseError]{
  %   \ana{\Gamma}{e}{\hole{}} \\
  %   \Set{ \ana{\Gamma,\asc{X_i}{\hole{}}}{e_i}{\hole{}} }_{C_i \in \TagSet}
  % }{
  %   \syn{\Gamma}{ \hole[ \Ecase{e}{ C_i(X_i){=}e_i} ]{u} }{\hole{}}
  % }

  \inferrule[SEHole]{
    %
  }{
    \syn{\Gamma}{ \hole{u} }{\hole{}}
  }

  \inferrule[SNEHole]{
    \syn{\Gamma}{e}{\tau}
  }{
    \syn{\Gamma}{ \hole[e]{u} }{\hole{}}
  }
\end{mathpar}

% \textsc{SInj} = Injection in Synthetic Position or Analyzed Against Non-Sum

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- E valid

\Judgment{
  \valid{\Gamma}{E}
}{
  $E$ is a valid optional expression
}

\begin{mathpar}
  \inferrule[EVPresent]{
    \ana{\Gamma}{e}{\hole{}}
  }{
    \valid{\Gamma}{e}
  }

  \inferrule[EVNotPresent]{
    %
  }{
    \valid{\Gamma}{\Missing}
  }
\end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- e <= tau

\Judgment{
  \ana{\Gamma}{e}{\tau}
}{
  $e$ analyzes against type $\tau$
}

\begin{mathpar}
  \inferrule[ARoll]{
    \MatchedRecTyp{\tau}{\pi}{\tau'} \\
    \ana{\Gamma}{e}{ \subst{\tau}{\pi}{\tau'} }
  }{
    \ana{\Gamma}{ \Eroll{e} }{\tau}
  }

  \inferrule[ARollNotRec]{
    \notconsistent{\tau}{\Trec{\hole{}}{\hole{}}}
  }{
    \ana{\Gamma}{ \hole[\Eroll{e}]{u} }{\tau}
  }

  \inferrule[AInjHole]{
    \valid{\Gamma}{E}
  }{
    \ana{\Gamma}{ \Einj{C}{E} }{\hole{}}
  }

  \inferrule[AInj]{
    C_j \in \TagSet \\
    \ana{\Gamma}{E}{T_j}
  }{
    \ana{\Gamma}{ \Einj{C_j}{E} }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjUnexpectedBody]{
    C_j \in \TagSet \\
    T_j = \Missing \\
    \ana{\Gamma}{e}{\hole{}}
  }{
    \ana{\Gamma}{ \hole[\Einj{C_j}{e}]{u} }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjExpectedBody]{
    C_j \in \TagSet \\
    T_j = \tau
  }{
    \ana{\Gamma}{ \hole[\Einj{C_j}{\Missing}]{u} }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[AInjBadTag]{
    C \notin \TagSet \\
    \valid{\Gamma}{E}
  }{
    \ana{\Gamma}{
      \hole[\Einj{C}{E}]{u}
    }{\Tsum{C_i(T_i)}_{C_i \in \TagSet}}
  }

  \inferrule[ASubsume]{
    \syn{\Gamma}{e}{\tau'} \\
    \consistent{\tau'}{\tau}
  }{
    \ana{\Gamma}{e}{\tau}
  }
\end{mathpar}

% \begin{mathpar}
%   \inferrule[ARoll]{
%     \matchedRec{\tau}{\rectype{\alpha}{\tau'}} \\
%     \ana{\Gamma}{e}{\subst{ \rectype{\alpha}{\tau'} }{\alpha}{\tau'}}
%   }{
%     \ana{\Gamma}{\eroll{e}}{\tau}
%   }

%   \inferrule[AInjHole]{
%     \valid{\Gamma}{E}
%   }{
%     \ana{\Gamma}{ \einj{C}{E} }{\hole}
%   }

%   \inferrule[AInj]{
%     C_j \in \C \\
%     \anaE{\Gamma}{E}{T_j}
%   }{
%     \ana{\Gamma}{
%       \einj{C_j}{E}
%     }{\sumtype{C_i(T_i)}_{C_i \in \C}}
%   }

%   \inferrule[AInjUnexpectedBody]{
%     C_j \in \C \\
%     T_j = \Nothing
%   }{
%     \ana{\Gamma}{
%       \hole[\einj{C_j}{e}]^u
%     }{\sumtype{C_i(T_i)}_{C_i \in \C}}
%   }

%   \inferrule[AInjExpectedBody]{
%     C_j \in \C \\
%     T_j = \tau
%   }{
%     \ana{\Gamma}{
%       \hole[\einj{C_j}{\Nothing}]^u
%     }{\sumtype{C_i(T_i)}_{C_i \in \C}}
%   }

%   \inferrule[AInjBadTag]{
%     C \notin \C \\
%     \valid{\Gamma}{E}
%   }{
%     \ana{\Gamma}{
%       \hole[\einj{C}{E}]^u
%     }{\sumtype{C_i(T_i)}_{C_i \in \C}}
%   }
% \end{mathpar}

\vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- E <= T

% \noindent
% $\boxed{\anaE{\Gamma}{E}{T}}$
% \quad $E$ analyzes against optional type $T$

% \begin{mathpar}
%   \inferrule[]{
%     \ana{\Gamma}{e}{\tau}
%   }{
%     \anaE{\Gamma}{e}{\tau}
%   }

%   \inferrule[]{
%     % 
%   }{
%     \anaE{\Gamma}{\Nothing}{\Nothing}
%   }
% \end{mathpar}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%  Gamma |- E <= T

\Judgment{
  \ana{\Gamma}{E}{T}
}{
  $E$ analyzes against optional type $T$
}

\begin{mathpar}
  \inferrule[APresent]{
    E = e \\
    T = \tau \\
    \ana{\Gamma}{e}{\tau}
  }{
    \ana{\Gamma}{E}{T}
  }

  \inferrule[ANotPresent]{
    %
  }{
    \ana{\Gamma}{\Missing}{\Missing}
  }
\end{mathpar}

\subsection{Typed Elaboration}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e => tau ~> d -| Delta

% \noindent
% $\boxed{\synelab{\Gamma}{e}{\tau}{d}{\Delta}}$
% \quad $e$ synthesizes type $\tau$ and elaborates to $d$

% \begin{mathpar}
%   \inferrule[ESUnroll]{
%     \synelab{\Gamma}{e}{\tau'}{d}{\Delta} \\
%     \matchedRec{\tau'}{\rectype{\alpha}{\tau}}
%   }{
%     \synelab{\Gamma}{
%       \unroll{e}
%     }{ \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau} }{
%       \unroll{d}
%     }{\Delta}
%   }

%   \inferrule[ESInj]{
%     \anaelabE{\Gamma}{E}{\hole}{D}{T}{\Delta}
%   }{
%     \synelab{\Gamma}{
%       \hole[\einj{C}{E}]^u
%     }{\hole}{
%       \hole[{\dinj{\hole}{C}{\cast{D}{T}{\hole}}}]_{\id(\Gamma)}^u
%     }{\Delta, u :: \hole{}[\Gamma]}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- e <= tau_1 ~> d : tau_2 -| Delta

% TODO: define D<T => T>
% TODO: add u as hole macro param

% \noindent
% $\boxed{\anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}}$
% \quad $e$ analyzes against type $\tau_1$ and elaborates to $d$ of consistent type $\tau_2$

% \begin{mathpar}
%   \inferrule[EARoll]{
%     \anaelab{\Gamma}{
%       e
%     }{\subst{ \rectype{\alpha}{\tau} }{\alpha}{\tau}}{
%       d
%     }{\tau'}{\Delta}
%   }{
%     \anaelab{\Gamma}{
%       \eroll{e}
%     }{\rectype{\alpha}{\tau}}{
%       \droll{\rectype{\alpha}{\tau}}{
%         \cast{d}{\tau'}{ \subst{ \rectype{\alpha}{\tau} }{\alpha}{\tau} }
%       }
%     }{\rectype{\alpha}{\tau}}{
%       \Delta
%     }
%   }

%   \inferrule[EAInj]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     C_j \in \C \\
%     \anaelab{\Gamma}{E}{T_j}{D}{T_j'}{\Delta}
%   }{
%     \anaelab{\Gamma}{
%       \einj{C_j}{E}
%     }{\tau}{
%       \dinj{\tau}{C_j}{\cast{D}{T_j'}{T_j}}
%     }{\tau}{\Delta}
%   }

%   \inferrule[EAInjHole]{
%     \anaelabE{\Gamma}{E}{\hole}{D}{T}{\Delta} \\
%     \tau = \sumtype{C(T)}
%   }{
%     \anaelab{\Gamma}{
%       \einj{C}{E}
%     }{\hole}{
%       \dinj{\tau}{C}{D}
%     }{\tau}{\Delta}
%   }

%   \inferrule[EAInjUnexpectedBody]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     C_j \in \C \\
%     T_j = \Nothing \\
%     \anaelab{\Gamma}{e}{\hole}{d}{\tau_j}{\Delta} \\
%     \tau' = \tau \uplus \sumtype{C_j(\tau_j)}
%   }{
%     \anaelab{\Gamma}{
%       \hole[\einj{C_j}{e}]^u
%     }{\tau}{
%       \hole[{\dinj{\tau'}{C_j}{d}}]_{\id(\Gamma)}^u
%     }{\tau}{\Delta, u :: \tau[\Gamma]}
%   }

%   \inferrule[EAInjExpectedBody]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     C_j \in \C \\
%     T_j = \tau_j \\
%     \tau' = \tau \uplus \sumtype{C_j(\Nothing)}
%   }{
%     \anaelab{\Gamma}{
%       \hole[\einj{C_j}{\Nothing}]^u
%     }{\tau}{
%       \hole[{\dinj{\tau'}{C_j}{\Nothing}}]_{\id(\Gamma)}^u
%     }{\tau}{\Delta, u :: \tau[\Gamma]}
%   }

%   \inferrule[EAInjBadTag]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     C \notin \C \\
%     \anaelabE{\Gamma}{E}{\hole}{D}{T}{\Delta} \\
%     \tau' = \tau \uplus \sumtype{C(T)}
%   }{
%     \anaelab{\Gamma}{
%       \hole[\einj{C}{E}]^u
%     }{\tau}{
%       \hole[{\dinj{\tau'}{C}{D}}]_{\id(\Gamma)}^u
%     }{\tau}{\Delta, u :: \tau[\Gamma]}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- E <= T_1 ~> D : T_2 -| Delta

% \noindent
% $\boxed{\anaelabE{\Gamma}{E}{T_1}{D}{T_2}{\Delta}}$
% \quad $E$ analyzes against optional type $T_1$ and elaborates to $D$ of consistent optional type $T_2$

% \begin{mathpar}
%   \inferrule{
%     \anaelab{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}   
%   }{
%     \anaelabE{\Gamma}{e}{\tau_1}{d}{\tau_2}{\Delta}
%   }

%   \inferrule{
%     % 
%   }{
%     \anaelabE{\Gamma}{\Nothing}{\Nothing}{\Nothing}{\Nothing}{\emptyset}
%   }
% \end{mathpar}

\subsection{Type Assignment}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Delta; Gamma |- d : tau

% \noindent
% $\boxed{\assign{\Delta}{\Gamma}{d}{\tau}}$
% \quad $d$ is assigned type $\tau$

% \begin{mathpar}
%   \inferrule[TRoll]{
%     \assign{\Delta}{\Gamma}{d}{ \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau} }
%   }{
%     \assign{\Delta}{\Gamma}{ \droll{\rectype{\alpha}{\tau}}{d} }{ \rectype{\alpha}{\tau} }
%   }

%   \inferrule[TUnroll]{
%     \assign{\Delta}{\Gamma}{d}{ \rectype{\alpha}{\tau} }
%   }{
%     \assign{\Delta}{\Gamma}{\unroll{d}}{ \subst{\rectype{\alpha}{\tau}}{\alpha}{\tau} }
%   }

%   \inferrule[TInj]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     C_j \in \C \\
%     \assign{\Delta}{\Gamma}{D}{T_j}
%   }{
%     \assign{\Delta}{\Gamma}{\dinj{\tau}{C_j}{D}}{\tau}
%   }

%   \inferrule[TCase]{
%     \assign{\Delta}{\Gamma}{d}{\sumtype{C_i(T_i)}_{C_i \in \C}} \\
%     \assign{\Delta}{\Gamma, X_i : T_i}{d_i}{\tau} \\
%     i = 1, \ldots, N
%   }{
%     \assign{\Delta}{\Gamma}{
%       \case{d}{C_i(X_i){=}d_i}_{C_i \in \C}
%     }{\tau}
%   }

%   \inferrule[TCaseU]{
%     \assign{\Delta}{\Gamma}{d}{\hole} \\
%     \assign{\Delta}{\Gamma, X_i : \hole}{d_i}{\tau} \\
%     i = 1, \ldots, N
%   }{
%     \assign{\Delta}a{\Gamma}{\case{d}{C_i(X_i){=}{d_i}}_{C_i \in \C}}{\tau}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Gamma |- D : T

% \noindent
% $\boxed{\assignD{\Delta}{\Gamma}{D}{T}}$
% \quad $D$ is assigned optional type $T$

% \begin{mathpar}
%   \inferrule{
%     \assign{\Delta}{\Gamma}{d}{\tau}
%   }{
%     \assignD{\Delta}{\Gamma}{d}{\tau}
%   }

%   \inferrule{
%     % 
%   }{
%     \assign{\Delta}{\Gamma}{\Nothing}{\Nothing}
%   }
% \end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dynamic Semantics}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \noindent
% $\boxed{\ground{\tau}}$
% \quad $\tau$ is a ground type

% \begin{mathpar}
%   \inferrule[GSum]{
%     \SetOf{T_i = \hole \vee T_i = \Nothing}_i
%   }{
%     \ground{\sumtype{C_i(T_i)}_{C_i \in \C}}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \noindent
% $\boxed{\matchedGround{\tau}{\tau'}}$
% \quad $\tau$ has matched ground type $\tau'$

% \begin{mathpar}
%   \inferrule[MGSum]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     \tau' = \sumtype{C_i(T_i')}_{C_i \in \C} \\
%     \tau \neq \tau' \\
%     \SetOf{
%       T_i =   \tau_i \implies T_i' = \hole \wedge
%       T_i = \Nothing \implies T_i' = \Nothing
%     }_i
%   }{
%     \matchedGround{\tau}{\tau'}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \noindent
% $\boxed{\val{d}}$
% \quad $d$ is a value

% \begin{mathpar}
%   \inferrule[VRoll]{
%     \val{d}
%   }{
%     \val{\droll{\rectype{\alpha}{\tau}}{d}}
%   }

%   \inferrule[VUnroll]{
%     \val{d}
%   }{
%     \val{\unroll{d}}
%   }

%   \inferrule[VInj]{
%     \val{d}
%   }{
%     \val{\dinj{\tau}{\Tag}{d}}
%   }

%   \inferrule[VInjNull]{
%   }{
%     \val{\dinj{\tau}{\Tag}{\Nothing}}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \noindent
% $\boxed{\boxedval{d}}$
% \quad $d$ is a boxed value

% \begin{mathpar}
%   \inferrule[BVRoll]{
%     \boxedval{d}
%   }{
%     \boxedval{\droll{\rectype{\alpha}{\tau}}{d}}
%   }

%   \inferrule[BVUnroll]{
%     \boxedval{d}
%   }{
%     \boxedval{\unroll{d}}
%   }

%   \inferrule[BVInj]{
%     \boxedval{d}
%   }{
%     \boxedval{\dinj{\tau}{\Tag}{d}}
%   }

%   \inferrule[BVSumCast]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     \tau' = \sumtype{C_i(T_i')}_{C_i \in \C} \\
%     \tau \neq \tau' \\
%     \boxedval{d}
%   }{
%     \boxedval{\cast{d}{\tau}{\tau'}}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \noindent
% $\boxed{\indet{d}}$
% \quad $d$ is indeterminate

% \begin{mathpar}
%   \inferrule[IRoll]{
%     \indet{d}
%   }{
%     \indet{\droll{\rectype{\alpha}{\tau}}{d}}
%   }

%   \inferrule[IUnroll]{
%     \indet{d}
%   }{
%     \indet{\unroll{d}}
%   }

%   \inferrule[IInj]{
%     \indet{d}
%   }{
%     \indet{\dinj{\tau}{\Tag}{d}}
%   }

%   \inferrule[IInjTag]{
%     \final{d}
%   }{
%     \indet{\dinj{\tau}{\TagHole}{d}}
%   }

%   \inferrule[IInjNull]{
%   }{
%     \indet{\dinj{\tau}{\TagHole}{\Nothing}}
%   }

%   \inferrule[ICastSum]{
%     \tau = \sumtype{C_i(T_i)}_{C_i \in \C} \\
%     \tau' = \sumtype{C_i(T_i')}_{C_i \in \C} \\
%     \tau \neq \tau' \\
%     \indet{d}
%   }{
%     \indet{\cast{d}{\tau}{\tau'}}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% \[
%   \arraycolsep=0pt  \arraycolsep=0pt
%   \begin{array}{l@{~~}c@{~~}c@{~~}l}
%     \EvalCtx & \E & {}\Coloneqq{} &
%       \ldots
%       \mid \droll{\rectype{\alpha}{\tau}}{\E}
%       \mid \dinj{\tau}{C}{\E}
%     \\
%   \end{array}
% \]

% \noindent
% $\boxed{\eval{d}{\E}{d'}}$
% \quad $d$ is obtained by placing $d'$ at the mark in $\E$

% \begin{mathpar}
%   \inferrule[FHRoll]{
%     \eval{d}{\E}{d'}
%   }{
%     \eval{
%       \droll{\rectype{\alpha}{\tau}}{d}
%     }{\droll{\rectype{\alpha}{\tau}}{\E}
%     }{d'}
%   }

%   \inferrule[FHUnroll]{
%     \eval{d}{\E}{d'}
%   }{
%     \eval{
%       \unroll{d}
%     }{\unroll{\E}
%     }{d'}
%   }

%   \inferrule[FHInj]{
%     \eval{d}{\E}{d'}
%   }{
%     \eval{
%       \dinj{\tau}{C}{d}
%     }{\dinj{\tau}{C}{\E}
%     }{d'}
%   }
% \end{mathpar}

% \vspace*{\baselineskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}