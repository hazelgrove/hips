\documentclass[index.tex]{subfiles}

\begin{document}
\subsection{Approach}
\label{approach}
This section outlines the approaches we take towards various aspects of compilation and execution
related to holes.

\subsubsection{Runtime representation}
\label{runtime-representation}
We represent indeterminate results as syntax trees in the runtime, and operations taking
indeterminate results merely accumulate a new syntax tree.
%
\begin{example}
  In the program $1 + (5 * 6 + \SyEHole{1}{})$, $5 * 6$ produces an ordinary number $30$, but the
  subsequent $+ \SyEHole{1}{}$ gives an indeterminate syntax tree with root $+$, left child $30$, and
  right child $\SyEHole{1}{}$. The final result is an indeterminate syntax tree with root $+$, left
  child $1$, and right child that is the previous tree.
\end{example}
%
\noindent This necessitates dynamics checks before each operation to determine whether operands are
values or indeterminate results; therefore, there must be some runtime data that discriminates
between values and indeterminate results.

\subsubsection{Casting}
\label{casting}

\paragraph{Embedding/projection}
In a first pass, we adopt a type-indexed embedding/projecting pairs approach \cite{benton2005,
new2018}: casting $x$ from type $\tau$ to the hole type \emph{embeds} $x$ with type information
about $\tau$ into a proxy; casting to the type $\tau'$ \emph{projects} the proxy, dynamically
checking if $\tau = \tau'$.

\paragraph{Coercions}
In the future, a coercion-based approach should be taken, which has some space efficiency guarantees
\cite{herman2010, kuhlenschmidt2019}.

\paragraph{Static analysis}
It should be possible, as with determining if expressions are possibly indeterminate at runtime
(\Cref{completeness-analysis}), to statically determine where casts might show up. This might lend
itself to some optimizations, particularly when casts appear as scrutinees of pattern matching
(\Cref{pattern-matching}).

\subsubsection{Pattern matching}
\label{pattern-matching}
It should be possible to compile pattern matching with holes into ordinary functional pattern
matching:
\begin{itemize}
  \item \emph{Hole patterns} may be compiled into wildcard patterns that immediately stop and return
    the entire $\textsf{match}$ expression as an indeterminate results.
  \item In the presence of casts, types must be matched on as data. This is something to consider
    when designing the runtime representation of indeterminate results
    (\Cref{runtime-representation}).
\end{itemize}

\subsubsection{Completeness analysis}
\label{completeness-analysis}
Since we want complete portions (i.e. no holes) of a program to run as ordinary functional programs
and not require the machinery necessary for handling holes, we perform a static \emph{completeness
analysis} that determines whether an expressions is guaranteed to be hole-free. To do this, we
define a notion of \emph{completeness}:
%
\begin{definition}[name=Completeness, label=completeness]
  An expression may be (1) \emph{necessarily complete}, i.e. it must be a value at runtime; (2)
  \emph{necessarily incomplete}, i.e. it must be an indeterminate result at runtime; or (3)
  \emph{indeterminately incomplete}, i.e. it may be either a value or an indeterminate result at
  runtime.
\end{definition}
%

\paragraph{Function-local completeness}
A basic function-local analysis which treats function parameters as indeterminately
incomplete by default may be implemented in a single pass over the expression tree.

\paragraph{CFA-based completeness}
A more complex analysis may use control-flow analysis techniques on higher-order functions
\cite{shivers1991, nielson1999}. Other papers to consider reading: \textcite{vardoulaskis2011} (but
apparently $2^{n}$ complexity), \textcite{gilray2016}.

\end{document}
